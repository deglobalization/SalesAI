<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="mobile-optimization.css">
    <title>데이터 기반 영업 분석 및 추천 시스템</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0b0d;
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .background-pattern {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            background-image: 
                radial-gradient(circle at 20% 50%, #00d4ff 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, #ff6b35 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, #7c3aed 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 30px 40px;
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(124, 58, 237, 0.1));
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        /* 탭 네비게이션 스타일 */
        .tab-navigation {
            display: flex;
            gap: 5px;
            margin-bottom: 30px;
            padding: 5px;
            background: rgba(17, 24, 39, 0.8);
            border-radius: 15px;
            border: 1px solid rgba(75, 85, 99, 0.3);
            backdrop-filter: blur(20px);
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .tab-navigation::-webkit-scrollbar {
            display: none;
        }

        .tab-button {
            flex: 1;
            min-width: 140px;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            background: transparent;
            color: #a1a1aa;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            white-space: nowrap;
        }

        .tab-button:hover {
            background: rgba(75, 85, 99, 0.3);
            color: #ffffff;
        }

        .tab-button.active {
            background: linear-gradient(135deg, #00d4ff, #7c3aed);
            color: #ffffff;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }

        .tab-button .icon {
            font-size: 1.1rem;
        }

        /* 탭 콘텐츠 */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .header-content {
            flex: 1;
            text-align: center;
        }

        .map-container {
            width: 400px;
            height: 300px;
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.1);
            background: rgba(17, 24, 39, 0.8);
            position: relative;
        }

        .map-title {
            position: absolute;
            top: 10px;
            left: 15px;
            background: rgba(17, 24, 39, 0.9);
            color: #00d4ff;
            padding: 5px 10px;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            z-index: 1000;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        #salesMap {
            width: 100%;
            height: 100%;
            border-radius: 13px;
        }

        /* 지역 하이라이트 스타일 */
        .leaflet-interactive.top-region {
            filter: drop-shadow(0 0 10px rgba(255, 107, 53, 0.8));
            transition: all 0.3s ease;
        }

        .leaflet-interactive.region-highlight {
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .leaflet-interactive.region-highlight:hover {
            filter: brightness(1.3) drop-shadow(0 0 8px currentColor);
            transform: scale(1.02);
        }

        /* 세부 지역 하이라이트 스타일 */
        .leaflet-interactive.top-detailed-region {
            filter: drop-shadow(0 0 15px rgba(255, 23, 68, 1.0));
            transition: all 0.2s ease;
            z-index: 1000;
        }

        .leaflet-interactive.detailed-region-highlight {
            transition: all 0.2s ease;
            cursor: pointer;
            z-index: 999;
        }

        .leaflet-interactive.detailed-region-highlight:hover {
            filter: brightness(1.4) drop-shadow(0 0 12px currentColor);
            transform: scale(1.05);
        }

        /* 세부 지역 라벨 스타일 */
        .detailed-region-label div {
            transition: all 0.3s ease;
        }

        .detailed-region-label div:hover {
            transform: scale(1.1) !important;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6) !important;
        }

        /* 팝업 스타일 개선 */
        .leaflet-popup-content-wrapper {
            background: rgba(17, 24, 39, 0.95) !important;
            border-radius: 12px !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            backdrop-filter: blur(10px) !important;
        }

        .leaflet-popup-tip {
            background: rgba(17, 24, 39, 0.95) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(135deg, #00d4ff, #7c3aed);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            letter-spacing: -0.02em;
        }

        .header p {
            font-size: 1.2rem;
            color: #a1a1aa;
            font-weight: 400;
        }

        .control-panel {
            background: rgba(17, 24, 39, 0.8);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 40px;
            border: 1px solid rgba(75, 85, 99, 0.3);
            backdrop-filter: blur(20px);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
        }

        .file-input-area {
            border: 2px dashed rgba(75, 85, 99, 0.5);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            margin-bottom: 25px;
            background: rgba(31, 41, 55, 0.3);
        }

        .file-input-area:hover, .file-input-area.dragover {
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.05);
        }

        .file-input {
            display: none;
        }

        .file-input-label, .demo-data-btn {
            display: inline-block;
            padding: 14px 28px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 0.95rem;
            border: none;
            position: relative;
            overflow: hidden;
        }

        .file-input-label {
            background: linear-gradient(135deg, #00d4ff, #0ea5e9);
            color: white;
            margin-right: 15px;
        }

        .demo-data-btn {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .file-input-label:hover, .demo-data-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        .analysis-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 12px 24px;
            border: 1px solid rgba(75, 85, 99, 0.5);
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            background: rgba(31, 41, 55, 0.8);
            color: #ffffff;
            font-size: 0.9rem;
            position: relative;
            overflow: hidden;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-1px);
            border-color: #00d4ff;
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.2);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(75, 85, 99, 0.3);
            border-radius: 2px;
            overflow: hidden;
            margin: 25px 0 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #7c3aed);
            width: 0%;
            transition: width 0.8s ease;
        }

        .status-message {
            padding: 15px 20px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: 500;
            border-left: 4px solid;
        }

        .status-success {
            background: rgba(16, 185, 129, 0.1);
            color: #10b981;
            border-left-color: #10b981;
        }

        .status-error {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            border-left-color: #ef4444;
        }

        .status-info {
            background: rgba(0, 212, 255, 0.1);
            color: #00d4ff;
            border-left-color: #00d4ff;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }

        .analysis-card {
            background: rgba(17, 24, 39, 0.8);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(75, 85, 99, 0.3);
            backdrop-filter: blur(20px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .analysis-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
        }

        .analysis-card h3 {
            color: #ffffff;
            margin-bottom: 20px;
            font-size: 1.3rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: rgba(31, 41, 55, 0.5);
            border-radius: 12px;
            border: 1px solid rgba(75, 85, 99, 0.2);
        }

        .clickable-stat:hover {
            background: rgba(255, 255, 255, 0.05) !important;
            transform: translateY(-2px);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5);
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #00d4ff;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.85rem;
            color: #9ca3af;
            font-weight: 500;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin: 20px 0;
        }

        .table-container {
            overflow-x: auto;
            margin-top: 15px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(31, 41, 55, 0.3);
            border-radius: 12px;
            overflow: hidden;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid rgba(75, 85, 99, 0.2);
        }

        th {
            background: rgba(17, 24, 39, 0.8);
            color: #00d4ff;
            font-weight: 600;
            font-size: 0.9rem;
        }

        td {
            color: #d1d5db;
            font-size: 0.9rem;
        }

        tr:hover {
            background: rgba(75, 85, 99, 0.1);
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            backdrop-filter: blur(10px);
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(0, 212, 255, 0.2);
            border-top: 4px solid #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        /* 매출액 기준 세그먼트 스타일 */
        .segment-sales-premium {
            background: linear-gradient(135deg, rgba(147, 51, 234, 0.2), rgba(126, 34, 206, 0.1));
            border-left: 4px solid #9333ea;
        }

        .segment-sales-high {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.1));
            border-left: 4px solid #10b981;
        }

        .segment-sales-medium {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.1));
            border-left: 4px solid #3b82f6;
        }

        .segment-sales-low {
            background: linear-gradient(135deg, rgba(107, 114, 128, 0.2), rgba(75, 85, 99, 0.1));
            border-left: 4px solid #6b7280;
        }

        /* BCG Matrix 세그먼트 스타일 */
        .segment-bcg-star {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 193, 7, 0.1));
            border-left: 4px solid #FFD700;
        }

        .segment-bcg-cash-cow {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(22, 163, 74, 0.1));
            border-left: 4px solid #22C55E;
        }

        .segment-bcg-question-mark {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(217, 119, 6, 0.1));
            border-left: 4px solid #f59e0b;
        }

        .segment-bcg-dog {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.1));
            border-left: 4px solid #ef4444;
        }

        .segment-bcg-basic {
            background: linear-gradient(135deg, rgba(107, 114, 128, 0.2), rgba(75, 85, 99, 0.1));
            border-left: 4px solid #6b7280;
        }

        .recommendation-item {
            background: rgba(31, 41, 55, 0.5);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 15px;
            border-left: 4px solid #7c3aed;
        }

        .recommendation-title {
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        .recommendation-description {
            color: #d1d5db;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .recommendation-metrics {
            display: flex;
            gap: 20px;
            font-size: 0.9rem;
            color: #9ca3af;
        }

        .export-formats {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .export-btn {
            padding: 8px 16px;
            background: rgba(124, 58, 237, 0.8);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            background: rgba(124, 58, 237, 1);
            transform: translateY(-1px);
        }

        .clickable-product {
            transition: all 0.3s ease;
        }

        .clickable-product:hover {
            color: #7c3aed !important;
            text-shadow: 0 0 8px rgba(0, 212, 255, 0.5);
            transform: scale(1.05);
        }

        .clickable-segment {
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .clickable-segment:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            filter: brightness(1.2);
        }

        .clickable-segment:active {
            transform: translateY(-1px) scale(1.02);
        }

        .clickable-segment::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, rgba(255, 255, 255, 0.1), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .clickable-segment:hover::before {
            opacity: 1;
        }

        /* 토글 스위치 스타일 */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(75, 85, 99, 0.5);
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: #d1d5db;
            transition: .4s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #00d4ff;
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(26px);
            background-color: white;
        }

        .toggle-slider:hover {
            box-shadow: 0 0 8px rgba(0, 212, 255, 0.3);
        }

        /* AI 로딩 애니메이션 */
        .loading-dot {
            color: #00d4ff;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .loading-dot:nth-child(1) {
            animation-delay: 0s;
        }

        .loading-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .loading-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes pulse {
            0%, 20% {
                opacity: 0.3;
                transform: scale(0.8);
            }
            50% {
                opacity: 1;
                transform: scale(1.1);
            }
            80%, 100% {
                opacity: 0.3;
                transform: scale(0.8);
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header {
                flex-direction: column;
                gap: 20px;
                text-align: center;
            }
            
            .header-content {
                flex: none;
            }
            
            .map-container {
                width: 100%;
                height: 250px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .analysis-grid {
                grid-template-columns: 1fr;
            }
            
            .analysis-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .btn {
                width: 100%;
                text-align: center;
            }
        }

        /* 모바일 반응형 CSS */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header {
                flex-direction: column;
                padding: 20px;
                margin-bottom: 15px;
                text-align: center;
            }

            .header h1 {
                font-size: 2rem;
                margin-bottom: 10px;
            }

            .header p {
                font-size: 1rem;
                margin-bottom: 20px;
            }

            .map-container {
                width: 100%;
                height: 250px;
                margin-top: 20px;
            }

            .control-panel {
                padding: 20px;
                margin-bottom: 20px;
            }

            .file-input-area {
                padding: 25px 15px;
            }

            .file-input-label, .demo-data-btn {
                display: block;
                width: 100%;
                margin: 10px 0;
                padding: 15px;
                font-size: 0.95rem;
            }

            .analysis-controls {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .btn {
                width: 100%;
                padding: 15px;
                font-size: 0.9rem;
            }

            .tab-navigation {
                margin-bottom: 20px;
                padding: 3px;
            }

            .tab-button {
                min-width: 110px;
                padding: 10px 15px;
                font-size: 0.85rem;
            }

            .tab-button .icon {
                font-size: 1rem;
            }

            .analysis-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .analysis-item {
                margin-bottom: 20px;
            }

            .analysis-item h3 {
                font-size: 1.2rem;
                margin-bottom: 15px;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .stat-card {
                padding: 15px;
            }

            .stat-value {
                font-size: 1.2rem;
            }

            .stat-label {
                font-size: 0.8rem;
            }

            .chart-container {
                height: 250px;
                margin: 15px 0;
            }

            .segmentation-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .segment-item {
                padding: 15px;
            }

            .segment-title {
                font-size: 1rem;
            }

            .customer-list {
                max-height: 200px;
            }

            .customer-item {
                padding: 10px;
                margin-bottom: 8px;
            }

            .recommendation-card {
                padding: 20px;
                margin-bottom: 15px;
            }

            .recommendation-title {
                font-size: 1.1rem;
                margin-bottom: 10px;
            }

            .recommendation-confidence {
                font-size: 0.8rem;
            }

            .export-options {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .export-btn {
                padding: 15px;
            }

            .loading-overlay {
                padding: 20px;
            }

            .loading-spinner {
                width: 40px;
                height: 40px;
            }

            .modal-content {
                margin: 20px;
                padding: 20px;
                max-height: calc(100vh - 40px);
                overflow-y: auto;
            }

            .modal h2 {
                font-size: 1.3rem;
                margin-bottom: 15px;
            }

            /* 터치 친화적 버튼 크기 */
            button, .btn, .tab-button {
                min-height: 44px;
                touch-action: manipulation;
            }

            /* 스크롤 개선 */
            .tab-navigation {
                -webkit-overflow-scrolling: touch;
                overflow-x: auto;
                flex-wrap: nowrap;
                padding-bottom: 5px;
            }

            .tab-button {
                flex: 0 0 auto;
                min-width: 100px;
                white-space: nowrap;
            }

            .tab-button .icon {
                display: block;
                margin-bottom: 2px;
            }

            .tab-button span:last-child {
                font-size: 0.75rem;
            }

            /* 작은 화면에서 텍스트 가독성 개선 */
            body {
                font-size: 16px;
                line-height: 1.5;
            }

            /* 지도 모바일 최적화 */
            .map-title {
                font-size: 0.8rem;
                padding: 3px 8px;
            }

            /* 팝업 모바일 최적화 */
            .leaflet-popup-content-wrapper {
                max-width: 250px !important;
            }
        }

        /* 태블릿 크기 최적화 */
        @media (min-width: 769px) and (max-width: 1024px) {
            .container {
                padding: 15px;
            }

            .header {
                padding: 30px;
            }

            .header h1 {
                font-size: 2.5rem;
            }

            .map-container {
                width: 350px;
                height: 280px;
            }

            .analysis-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 20px;
            }

            .stats-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .segmentation-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .tab-button {
                min-width: 130px;
                padding: 11px 18px;
            }
        }

        /* 초소형 화면 (320px 이하) 최적화 */
        @media (max-width: 320px) {
            .header h1 {
                font-size: 1.6rem;
            }

            .header p {
                font-size: 0.9rem;
            }

            .tab-button {
                min-width: 90px;
                padding: 8px 12px;
                font-size: 0.8rem;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .stat-card {
                padding: 12px;
            }

            .btn {
                padding: 12px;
                font-size: 0.85rem;
            }
        }
        

    </style>
    
    <!-- Chart.js 라이브러리 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Papa Parse (CSV 파싱) -->
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <!-- Leaflet 지도 라이브러리 -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="manager_selection.js"></script>
    <script src="batch_manager_loader.js"></script>
    <script src="manager_list_display.js"></script>
<script src="manager_recommendation_integration.js"></script>
<script src="customer_recommendations_integration.js"></script>
<script src="customer_status_checker.js"></script>
</head>
<body>
    <div class="background-pattern"></div>
    
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>

    <div class="container">
        <div class="header">
            <div class="header-content">
                <h1>📊 데이터 기반 영업 분석 및 추천 시스템</h1>
                <p>데이터 기반 영업 분석 및 추천 시스템</p>
                <div id="chromeAiStatus" style="margin-top: 10px; font-size: 0.9rem; color: #94a3b8;">
                    🔄 AI 시스템 초기화 중...
                </div>
                
                <!-- AI 설정 토글 -->
                    </button>
                </div>
                
                <!-- AI 설정 패널 (기본적으로 숨김) -->
                <div id="aiSettingsPanel" style="display: none; margin-top: 15px; padding: 15px; background: rgba(31, 41, 55, 0.5); border: 1px solid rgba(75, 85, 99, 0.3); border-radius: 8px;">
                    <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 10px;">
                        <h4 style="margin: 0; color: #e5e7eb; font-size: 0.95rem;">🤖 AI 시스템 설정</h4>
                        <button onclick="toggleAISettings()" style="background: none; border: none; color: #9ca3af; cursor: pointer; font-size: 1.1rem;">✕</button>
                    </div>
                    
                    <!-- 기본 설정 그룹 -->
                    <div id="basicAISettings">
                        <p style="margin: 8px 0; color: #9ca3af; font-size: 0.8rem;">
                            🧠 현재 지능형 규칙 기반 분석이 활성화되어 있습니다.
                        </p>
                        <div style="margin: 10px 0;">
                            <label style="color: #e5e7eb; font-size: 0.85rem; margin-bottom: 5px; display: block;">고급 AI 활성화 비밀번호:</label>
                            <input type="password" id="aiPasswordInput" placeholder="비밀번호를 입력하세요" 
                                   style="width: 100%; padding: 8px; background: rgba(17, 24, 39, 0.8); border: 1px solid rgba(75, 85, 99, 0.5); border-radius: 4px; color: #e5e7eb; font-size: 0.85rem;">
                        </div>
                        <div style="margin: 8px 0; padding: 8px; background: rgba(99, 102, 241, 0.1); border-radius: 4px; border-left: 3px solid #6366f1;">
                            <p style="color: #a5b4fc; font-size: 0.8rem; margin: 0;">
                                💡 올바른 비밀번호 입력 시 고급 AI 분석 기능이 활성화됩니다.
                            </p>
                        </div>
                        <div style="display: flex; gap: 8px; margin-top: 10px;">
                            <button onclick="validateAIPassword()" style="background: #6366f1; color: white; border: none; border-radius: 4px; padding: 6px 12px; cursor: pointer; font-size: 0.8rem;">
                                🚀 AI 활성화
                            </button>
                            <button onclick="resetToBasicAI()" style="background: #6b7280; color: white; border: none; border-radius: 4px; padding: 6px 12px; cursor: pointer; font-size: 0.8rem;">
                                🔄 기본 모드
                            </button>
                        </div>
                    </div>
                    
                    <!-- 고급 설정 그룹 (비밀번호 입력 후 표시) -->
                    <div id="advancedAISettings" style="display: none;">
                        <p style="margin: 8px 0; color: #10b981; font-size: 0.8rem;">
                
                <!-- 현재 담당자 정보 패널 -->
                <div id="currentManagerInfo" style="display: none; margin-top: 15px; padding: 15px; background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.3); border-radius: 8px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 1.2rem;">👤</span>
                        <span id="managerInfoText" style="color: #4ade80; font-size: 0.9rem;">담당자 미선택</span>
                    </div>
                </div>                             ✅ 고급 AI 시스템이 활성화되었습니다. Hugging Face AI를 사용합니다.
                        </p>
                        <div style="margin: 10px 0;">
                            <label style="color: #e5e7eb; font-size: 0.85rem; margin-bottom: 5px; display: block;">Hugging Face API 토큰:</label>
                            <input type="password" id="hfApiKeyInput" placeholder="hf_xxxxxxxxxxxxxxxx" 
                                   style="width: 100%; padding: 8px; background: rgba(17, 24, 39, 0.8); border: 1px solid rgba(16, 185, 129, 0.5); border-radius: 4px; color: #e5e7eb; font-size: 0.85rem;"
                                   value="DEMO_HUGGINGFACE_TOKEN_HERE" readonly>
                        </div>
                        <div style="margin: 8px 0; padding: 8px; background: rgba(16, 185, 129, 0.1); border-radius: 4px; border-left: 3px solid #10b981;">
                            <p style="color: #10b981; font-size: 0.8rem; margin: 0;">
                                🔑 사전 구성된 고급 AI 토큰이 자동으로 로드되었습니다.
                            </p>
                        </div>
                        <div style="display: flex; gap: 8px; margin-top: 10px;">
                            <button onclick="resetToBasicAI()" style="background: #ef4444; color: white; border: none; border-radius: 4px; padding: 6px 12px; cursor: pointer; font-size: 0.8rem;">
                                🔒 AI 비활성화
                            </button>
                            <a href="https://huggingface.co/settings/tokens" target="_blank" style="background: #6366f1; color: white; border: none; border-radius: 4px; padding: 6px 12px; text-decoration: none; font-size: 0.8rem;">
                                🔑 토큰 정보
                            </a>
                        </div>
                    </div>
                </div>
            </div>
            <div class="map-container">
                <div class="map-title">📍 지역 지도</div>
                <div id="salesMap"></div>
            </div>
        </div>

        <!-- 탭 네비게이션 -->
        <div class="tab-navigation">
            <button class="tab-button active" onclick="switchTab('upload')" id="uploadTab">
                <span class="icon">📁</span>
                <span>데이터 업로드</span>
            </button>
            <button class="tab-button" onclick="switchTab('analysis')" id="analysisTab">
                <span class="icon">📊</span>
                <span>기본 분석</span>
            </button>
            <button class="tab-button" onclick="switchTab('segmentation')" id="segmentationTab">
                <span class="icon">🎯</span>
                <span>고객 세분화</span>
            </button>
            <button class="tab-button" onclick="switchTab('recommendation')" id="recommendationTab">
                <span class="icon">💡</span>
                                        <span>🎯 SmartAI 추천</span>
            </button>
            <button class="tab-button" onclick="switchTab('export')" id="exportTab">
                <span class="icon">📤</span>
                <span>결과 내보내기</span>
            </button>
        </div>

        <!-- 탭 콘텐츠 -->
        <div id="uploadContent" class="tab-content active">
            <div class="control-panel">
            <div class="file-input-area" id="fileInputArea" style="display: none;">
                <input type="file" id="fileInput" class="file-input" accept=".csv,.xlsx,.xls">
                <label for="fileInput" class="file-input-label">📁 CSV 파일 업로드</label>
                <button class="demo-data-btn" onclick="generateDemoData()">🎯 데모 데이터 생성</button>
                <p style="margin-top: 15px; color: #9ca3af; font-size: 0.9rem;">
                    CSV 파일을 드래그 앤 드롭하거나 버튼을 클릭하여 업로드하세요
                </p>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <div id="statusMessage" class="status-message hidden">
                상태 메시지가 여기에 표시됩니다.
            </div>

            <div class="analysis-controls">
                <button class="btn" id="basicAnalysisBtn" onclick="performBasicAnalysis()" disabled>
                    📊 기본 분석 시작
                </button>
                <button class="btn" id="manualUploadBtn" onclick="showManualUpload()" style="display: none;">
                    📁 다른 파일 업로드
                </button>
            </div>
            </div>
        </div>

        <!-- 기본 분석 탭 -->
        <div id="analysisContent" class="tab-content">
            <div class="control-panel">
                <div class="analysis-controls">
                    <button class="btn" id="segmentationBtn" onclick="performCustomerSegmentation()" disabled>
                        🎯 고객 세분화 시작
                    </button>
                </div>
            </div>
            <div class="analysis-grid" id="analysisGrid">
                <!-- 기본 분석 결과가 여기에 표시됩니다 -->
            </div>
        </div>

        <!-- 고객 세분화 탭 -->
        <div id="segmentationContent" class="tab-content">
            <div class="control-panel">
                <div class="analysis-controls">
                    <button class="btn" id="recommendationBtn" onclick="generateRecommendations()" disabled>
                        🎯 SmartAI 추천 생성
                    </button>
                </div>
            </div>
            <div class="analysis-grid" id="segmentationGrid">
                <!-- 고객 세분화 결과가 여기에 표시됩니다 -->
            </div>
        </div>

        <!-- AI 추천 탭 -->
        <div id="recommendationContent" class="tab-content">
            <div class="control-panel">
                <div class="analysis-controls">
                    <!-- SmartAI 품목 즉시 검색 기능 -->
                    <div class="instant-search-container" style="background: rgba(17, 24, 39, 0.8); border: 1px solid rgba(75, 85, 99, 0.3); border-radius: 15px; padding: 20px; margin-bottom: 20px; backdrop-filter: blur(20px);">
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                            <div style="font-size: 1.3rem;">🔍</div>
                            <div>
                                <h3 style="margin: 0; color: #00d4ff;">SmartAI 품목 즉시 검색</h3>
                                <p style="margin: 5px 0 0 0; color: #9ca3af; font-size: 0.9rem;">품목명을 입력하여 실시간으로 타겟 추천을 받아보세요</p>
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px;">
                            <input type="text" 
                                   id="instantSearchInput" 
                                   placeholder="예: 졸피드, 가바페닌, 란소졸 등..." 
                                   style="flex: 1; padding: 12px 15px; border: 2px solid rgba(75, 85, 99, 0.5); border-radius: 8px; font-size: 1rem; background: rgba(55, 65, 81, 0.5); color: #ffffff; transition: border-color 0.3s ease;"
                                   onkeyup="handleInstantSearchAdvisor(event)"
                                   oninput="showSearchSuggestionsAdvisor()">
                            <button onclick="performInstantSearchAdvisor()" 
                                    style="background: linear-gradient(135deg, #00d4ff 0%, #7c3aed 100%); color: white; border: none; padding: 12px 20px; border-radius: 8px; cursor: pointer; font-weight: 500; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);">
                                🚀 SmartAI 검색
                            </button>
                        </div>
                        
                        <!-- 검색 제안 드롭다운 -->
                        <div id="searchSuggestionsAdvisor" style="display: none; position: relative; z-index: 100;"></div>
                        
                        <!-- 최근 검색어 -->
                        <div id="recentSearchesAdvisor" style="display: none;">
                            <div style="font-size: 0.9rem; color: #9ca3af; margin-bottom: 8px;">최근 검색:</div>
                            <div id="recentSearchesListAdvisor" style="display: flex; gap: 8px; flex-wrap: wrap;"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="analysis-grid" id="recommendationGrid">
                <!-- AI 추천 결과가 여기에 표시됩니다 -->
            </div>
        </div>

        <!-- 결과 내보내기 탭 -->
        <div id="exportContent" class="tab-content">
            <div class="control-panel">
                <div class="analysis-controls">
                    <button class="btn" id="exportBtn" onclick="exportAnalysis()" disabled>
                        📤 결과 내보내기
                    </button>
                </div>
            </div>
            <div class="analysis-grid" id="exportGrid">
                <!-- 내보내기 옵션이 여기에 표시됩니다 -->
            </div>
        </div>
    </div>

    <script>
        // 전역 변수들
        var salesData = [];
        var processedData = {};
        var analysisResults = {};
        var librariesLoaded = false;
        var salesMap = null;

        // 탭 전환 함수
        function switchTab(tabName) {
            // 모든 탭 버튼에서 active 클래스 제거
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            
            // 모든 탭 콘텐츠 숨기기
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // 선택된 탭 버튼에 active 클래스 추가
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // 선택된 탭 콘텐츠 표시
            document.getElementById(tabName + 'Content').classList.add('active');

            // 탭별 특별 처리
            if (tabName === 'upload') {
                // 업로드 탭에서 파일 입력 영역 표시
                const fileInputArea = document.getElementById('fileInputArea');
                if (fileInputArea && salesData.length === 0) {
                    fileInputArea.style.display = 'block';
                }
            }
        }

        // 자동 탭 전환 함수 (분석 진행 시)
        function autoSwitchTab(tabName) {
            setTimeout(() => {
                switchTab(tabName);
            }, 500);
        }

        // 한국 지역 정보 (중심좌표, 경계, 지역명)
        const regionData = {
            '서울': { 
                lat: 37.5665, lng: 126.9780, name: '서울특별시',
                bounds: [[37.7, 126.7], [37.4, 127.2]] // [북서, 남동]
            },
            '부산': { 
                lat: 35.1796, lng: 129.0756, name: '부산광역시',
                bounds: [[35.4, 128.8], [35.0, 129.3]]
            },
            '대구': { 
                lat: 35.8722, lng: 128.6014, name: '대구광역시',
                bounds: [[36.0, 128.4], [35.7, 128.8]]
            },
            '인천': { 
                lat: 37.4563, lng: 126.7052, name: '인천광역시',
                bounds: [[37.7, 126.3], [37.2, 126.9]]
            },
            '광주': { 
                lat: 35.1595, lng: 126.8526, name: '광주광역시',
                bounds: [[35.3, 126.7], [35.0, 127.0]]
            },
            '대전': { 
                lat: 36.3504, lng: 127.3845, name: '대전광역시',
                bounds: [[36.5, 127.2], [36.2, 127.5]]
            },
            '울산': { 
                lat: 35.5384, lng: 129.3114, name: '울산광역시',
                bounds: [[35.7, 129.0], [35.4, 129.5]]
            },
            '세종': { 
                lat: 36.4800, lng: 127.2890, name: '세종특별자치시',
                bounds: [[36.6, 127.1], [36.3, 127.4]]
            },
            '경기': { 
                lat: 37.4138, lng: 127.5183, name: '경기도',
                bounds: [[38.0, 126.4], [36.8, 127.9]]
            },
            '강원': { 
                lat: 37.8228, lng: 128.1555, name: '강원도',
                bounds: [[38.6, 127.0], [37.0, 129.4]]
            },
            '충북': { 
                lat: 36.8, lng: 127.7, name: '충청북도',
                bounds: [[37.2, 127.2], [36.2, 128.5]]
            },
            '충남': { 
                lat: 36.5, lng: 126.8, name: '충청남도',
                bounds: [[37.1, 125.9], [36.0, 127.6]]
            },
            '전북': { 
                lat: 35.7175, lng: 127.153, name: '전라북도',
                bounds: [[36.2, 126.4], [35.2, 127.8]]
            },
            '전남': { 
                lat: 34.8679, lng: 126.991, name: '전라남도',
                bounds: [[35.4, 126.0], [34.0, 127.7]]
            },
            '경북': { 
                lat: 36.4919, lng: 128.888, name: '경상북도',
                bounds: [[37.5, 128.0], [35.7, 130.0]]
            },
            '경남': { 
                lat: 35.4606, lng: 128.2132, name: '경상남도',
                bounds: [[36.0, 127.5], [34.6, 129.2]]
            },
            '제주': { 
                lat: 33.4996, lng: 126.5312, name: '제주특별자치도',
                bounds: [[33.6, 126.1], [33.1, 127.0]]
            }
        };

        // 시/군/구 세부 지역 정보
        const detailedRegionData = {
            // 서울 구
            '강남': { lat: 37.5173, lng: 127.0473, name: '강남구', parent: '서울', bounds: [[37.54, 127.02], [37.49, 127.07]] },
            '강북': { lat: 37.6379, lng: 127.0258, name: '강북구', parent: '서울', bounds: [[37.66, 127.00], [37.61, 127.05]] },
            '송파': { lat: 37.5145, lng: 127.1059, name: '송파구', parent: '서울', bounds: [[37.54, 127.08], [37.49, 127.13]] },
            '마포': { lat: 37.5663, lng: 126.9019, name: '마포구', parent: '서울', bounds: [[37.59, 126.88], [37.54, 126.93]] },
            '용산': { lat: 37.5326, lng: 126.9906, name: '용산구', parent: '서울', bounds: [[37.56, 126.97], [37.51, 127.02]] },
            '종로': { lat: 37.5735, lng: 126.9788, name: '종로구', parent: '서울', bounds: [[37.60, 126.96], [37.55, 127.01]] },
            '서초': { lat: 37.4837, lng: 127.0324, name: '서초구', parent: '서울', bounds: [[37.51, 127.01], [37.46, 127.06]] },
            '관악': { lat: 37.4781, lng: 126.9515, name: '관악구', parent: '서울', bounds: [[37.50, 126.93], [37.45, 126.98]] },
            '동작': { lat: 37.5124, lng: 126.9393, name: '동작구', parent: '서울', bounds: [[37.54, 126.92], [37.49, 126.97]] },
            '영등포': { lat: 37.5264, lng: 126.8963, name: '영등포구', parent: '서울', bounds: [[37.55, 126.88], [37.50, 126.93]] },
            
            // 경기도 주요 시
            '수원': { lat: 37.2636, lng: 127.0286, name: '수원시', parent: '경기', bounds: [[37.32, 126.98], [37.21, 127.08]] },
            '성남': { lat: 37.4201, lng: 127.1262, name: '성남시', parent: '경기', bounds: [[37.47, 127.08], [37.37, 127.17]] },
            '고양': { lat: 37.6584, lng: 126.8320, name: '고양시', parent: '경기', bounds: [[37.72, 126.78], [37.60, 126.88]] },
            '용인': { lat: 37.2411, lng: 127.1776, name: '용인시', parent: '경기', bounds: [[37.30, 127.13], [37.18, 127.22]] },
            '부천': { lat: 37.5034, lng: 126.7660, name: '부천시', parent: '경기', bounds: [[37.53, 126.74], [37.48, 126.79]] },
            '안산': { lat: 37.3219, lng: 126.8309, name: '안산시', parent: '경기', bounds: [[37.36, 126.79], [37.28, 126.87]] },
            '안양': { lat: 37.3943, lng: 126.9568, name: '안양시', parent: '경기', bounds: [[37.42, 126.93], [37.37, 126.98]] },
            '남양주': { lat: 37.6364, lng: 127.2167, name: '남양주시', parent: '경기', bounds: [[37.72, 127.15], [37.55, 127.28]] },
            '화성': { lat: 37.1999, lng: 126.8310, name: '화성시', parent: '경기', bounds: [[37.28, 126.75], [37.12, 126.91]] },
            '평택': { lat: 37.0000, lng: 127.1120, name: '평택시', parent: '경기', bounds: [[37.05, 127.06], [36.95, 127.16]] },
            '의정부': { lat: 37.7381, lng: 127.0338, name: '의정부시', parent: '경기', bounds: [[37.77, 127.00], [37.71, 127.07]] },
            '시흥': { lat: 37.3803, lng: 126.8028, name: '시흥시', parent: '경기', bounds: [[37.42, 126.76], [37.34, 126.85]] },
            '파주': { lat: 37.7595, lng: 126.7804, name: '파주시', parent: '경기', bounds: [[37.82, 126.72], [37.70, 126.84]] },
            '광명': { lat: 37.4786, lng: 126.8645, name: '광명시', parent: '경기', bounds: [[37.50, 126.84], [37.46, 126.89]] },
            '김포': { lat: 37.6152, lng: 126.7157, name: '김포시', parent: '경기', bounds: [[37.67, 126.67], [37.56, 126.76]] },
            '군포': { lat: 37.3617, lng: 126.9353, name: '군포시', parent: '경기', bounds: [[37.38, 126.91], [37.34, 126.96]] },
            '이천': { lat: 37.2721, lng: 127.4350, name: '이천시', parent: '경기', bounds: [[37.32, 127.38], [37.22, 127.49]] },
            '양주': { lat: 37.7855, lng: 127.0459, name: '양주시', parent: '경기', bounds: [[37.82, 127.00], [37.75, 127.09]] },
            '오산': { lat: 37.1500, lng: 127.0772, name: '오산시', parent: '경기', bounds: [[37.17, 127.05], [37.13, 127.10]] },
            '구리': { lat: 37.5943, lng: 127.1295, name: '구리시', parent: '경기', bounds: [[37.62, 127.10], [37.57, 127.16]] },
            '하남': { lat: 37.5394, lng: 127.2148, name: '하남시', parent: '경기', bounds: [[37.57, 127.19], [37.51, 127.24]] },
            '양평': { lat: 37.4919, lng: 127.4875, name: '양평군', parent: '경기', bounds: [[37.57, 127.40], [37.41, 127.57]] },
            '연천': { lat: 38.0960, lng: 127.0757, name: '연천군', parent: '경기', bounds: [[38.18, 127.01], [38.01, 127.14]] },
            
            // 부산 구
            '해운대': { lat: 35.1631, lng: 129.1635, name: '해운대구', parent: '부산', bounds: [[35.19, 129.14], [35.14, 129.19]] },
            '사상': { lat: 35.1520, lng: 128.9910, name: '사상구', parent: '부산', bounds: [[35.17, 128.97], [35.13, 129.01]] },
            '부산진': { lat: 35.1622, lng: 129.0537, name: '부산진구', parent: '부산', bounds: [[35.18, 129.03], [35.14, 129.08]] },
            
            // 인천 구
            '부평': { lat: 37.5070, lng: 126.7219, name: '부평구', parent: '인천', bounds: [[37.53, 126.70], [37.48, 126.75]] },
            '남동': { lat: 37.4470, lng: 126.7314, name: '남동구', parent: '인천', bounds: [[37.48, 126.70], [37.41, 126.76]] },
            '계양': { lat: 37.5372, lng: 126.7379, name: '계양구', parent: '인천', bounds: [[37.56, 126.71], [37.51, 126.77]] },
            
            // 강원도 주요 시
            '춘천': { lat: 37.8813, lng: 127.7298, name: '춘천시', parent: '강원', bounds: [[37.94, 127.67], [37.82, 127.79]] },
            '원주': { lat: 37.3422, lng: 127.9202, name: '원주시', parent: '강원', bounds: [[37.39, 127.87], [37.29, 127.97]] },
            '강릉': { lat: 37.7519, lng: 128.8761, name: '강릉시', parent: '강원', bounds: [[37.80, 128.83], [37.70, 128.92]] },
            '속초': { lat: 38.2070, lng: 128.5918, name: '속초시', parent: '강원', bounds: [[38.24, 128.56], [38.17, 128.62]] },
            
            // 충청북도 주요 시
            '청주': { lat: 36.6424, lng: 127.4890, name: '청주시', parent: '충북', bounds: [[36.70, 127.44], [36.58, 127.54]] },
            '충주': { lat: 36.9910, lng: 127.9259, name: '충주시', parent: '충북', bounds: [[37.04, 127.88], [36.94, 127.97]] },
            '제천': { lat: 37.1326, lng: 128.1907, name: '제천시', parent: '충북', bounds: [[37.18, 128.14], [37.09, 128.24]] },
            
            // 충청남도 주요 시
            '천안': { lat: 36.8151, lng: 127.1139, name: '천안시', parent: '충남', bounds: [[36.87, 127.06], [36.76, 127.17]] },
            '아산': { lat: 36.7898, lng: 127.0016, name: '아산시', parent: '충남', bounds: [[36.83, 126.96], [36.75, 127.04]] },
            '서산': { lat: 36.7848, lng: 126.4503, name: '서산시', parent: '충남', bounds: [[36.82, 126.41], [36.75, 126.49]] },
            '공주': { lat: 36.4465, lng: 127.1189, name: '공주시', parent: '충남', bounds: [[36.49, 127.08], [36.40, 127.16]] }
        };

        // 거래처명에서 지역 추정 함수 (세부 지역 우선)
        function estimateRegionFromName(accountName, managerArea = null) {
            // 1. 먼저 세부 지역(시/군/구) 확인
            // 0. 담당자 지역 정보 기반 매핑 (우선순위 최상위)
            if (managerArea) {
                const areaMapping = {
                    '경기/인천2지역': { region: '경기', detailedRegion: '구리', detailedInfo: detailedRegionData['구리'] }
                };
                
                if (areaMapping[managerArea]) {
                    return areaMapping[managerArea];
                }
            }             for (const [detailRegion, info] of Object.entries(detailedRegionData)) {
                if (accountName.includes(detailRegion) || accountName.includes(info.name)) {
                    return {
                        region: info.parent,
                        detailedRegion: detailRegion,
                        detailedInfo: info
                    };
                }
            }
            
            // 2. 광역 지역명이 거래처명에 포함되어 있는지 확인
            for (const [region, info] of Object.entries(regionData)) {
                if (accountName.includes(region) || accountName.includes(info.name)) {
                    return {
                        region: region,
                        detailedRegion: null,
                        detailedInfo: null
                    };
                }
            }
            
            // 3. 특정 키워드로 세부 지역 추정
            for (const [detailRegion, info] of Object.entries(detailedRegionData)) {
                if (accountName.includes(detailRegion)) {
                    return {
                        region: info.parent,
                        detailedRegion: detailRegion,
                        detailedInfo: info
                    };
                }
            }
            
            // 4. 광역 지역 키워드로 추정
            const regionKeywords = {
                '서울': ['강서', '중구', '금천', '구로', '노원', '도봉', '성북', '서대문', '중랑', '동대문', '성동', '광진', '은평'],
                '부산': ['동래', '남구', '북구', '사하', '금정', '연제', '수영', '강서구', '기장'],
                '대구': ['달서', '수성', '달성', '북구', '중구', '동구', '서구', '남구'],
                '인천': ['서구', '중구', '동구', '연수', '남구', '강화', '옹진'],
                '경기': ['광주시', '안성', '포천', '의왕', '여주', '동두천', '과천', '가평'],
                '강원': ['동해', '태백', '삼척', '홍천', '횡성', '영월', '평창', '정선', '철원', '화천', '양구', '인제', '고성', '양양'],
                '충북': ['보은', '옥천', '영동', '증평', '진천', '괴산', '음성', '단양'],
                '충남': ['보령', '논산', '계룡', '당진', '금산', '부여', '서천', '청양', '홍성', '예산', '태안'],
                '전북': ['전주', '군산', '익산', '정읍', '남원', '김제', '완주', '진안', '무주', '장수', '임실', '순창', '고창', '부안'],
                '전남': ['목포', '여수', '순천', '나주', '광양', '담양', '곡성', '구례', '고흥', '보성', '화순', '장흥', '강진', '해남', '영암', '무안', '함평', '영광', '장성', '완도', '진도', '신안'],
                '경북': ['포항', '경주', '김천', '안동', '구미', '영주', '영천', '상주', '문경', '경산', '군위', '의성', '청송', '영양', '영덕', '청도', '고령', '성주', '칠곡', '예천', '봉화', '울진', '울릉'],
                '경남': ['창원', '진주', '통영', '사천', '김해', '밀양', '거제', '양산', '의령', '함안', '창녕', '고성', '남해', '하동', '산청', '함양', '거창', '합천'],
                '제주': ['제주시', '서귀포']
            };
            
            for (const [region, keywords] of Object.entries(regionKeywords)) {
                for (const keyword of keywords) {
                    if (accountName.includes(keyword)) {
                        return {
                            region: region,
                            detailedRegion: null,
                            detailedInfo: null
                        };
                    }
                }
            }
            
            // 추정 불가능한 경우 기본값
            return {
                region: '기타',
                detailedRegion: null,
                detailedInfo: null
            };
        }

        // 라이브러리 로드 확인
        function ensureLibrariesLoaded() {
            if (typeof Chart === 'undefined' || typeof Papa === 'undefined' || typeof L === 'undefined') {
                showStatus('필요한 라이브러리를 로딩 중입니다...', 'info');
                return false;
            }
            return true;
        }

        // 지도 초기화
        function initializeMap() {
            if (salesMap) {
                salesMap.remove();
            }

            // 한국 중심 좌표로 지도 초기화
            salesMap = L.map('salesMap', {
                center: [36.5, 127.8],
                zoom: 7,
                zoomControl: false,
                attributionControl: false,
                dragging: true,
                touchZoom: true,
                scrollWheelZoom: true,
                doubleClickZoom: true,
                minZoom: 6,
                maxZoom: 12
            });

            // 어두운 테마의 타일 레이어 추가
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(salesMap);

            // 전체 보기 버튼 추가
            const resetControl = L.control({position: 'topright'});
            resetControl.onAdd = function(map) {
                const div = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
                div.innerHTML = '<button onclick="resetMapView()" style="background: rgba(17, 24, 39, 0.9); color: #00d4ff; border: none; padding: 8px; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">🌍 전체</button>';
                div.style.backgroundColor = 'transparent';
                div.style.border = 'none';
                return div;
            };
            resetControl.addTo(salesMap);

            updateRegionalMap();
        }

        // 지역별 매출 데이터로 지도 업데이트 (지역 강조 시스템)
        let currentRegionLayers = [];
        
        function updateRegionalMap() {
            if (!salesMap || !salesData || salesData.length === 0) return;

            // 기존 레이어 제거
            currentRegionLayers.forEach(layer => {
                salesMap.removeLayer(layer);
            });
            currentRegionLayers = [];

            // 최근 월 데이터로 지역별 매출 계산 (세부 지역 포함)
            const analysisRecentMonthData = salesData.filter(row => row['기준년월'] === processedData.recentMonth); console.log('분석용 최근월 데이터:', { analysisDataCount: analysisRecentMonthData.length, analysisRecentMonthSales: sumBy(analysisRecentMonthData, '총매출'), processedDataRecentMonthSales: processedData.recentMonthSales }); const recentMonthData = analysisRecentMonthData;
            const regionalSales = {};
            const detailedRegionalSales = {};

            recentMonthData.forEach(row => {
                const estimatedResult = estimateRegionFromName(row['거래처명'], row['담당자지역'] || row['지역'] || null);
                
                if (estimatedResult.region !== '기타') {
                    // 광역 지역별 매출
                    if (regionData[estimatedResult.region]) {
                        regionalSales[estimatedResult.region] = (regionalSales[estimatedResult.region] || 0) + (row['총매출'] || 0);
                    }
                    
                    // 세부 지역별 매출 (세부 지역이 확인된 경우)
                    if (estimatedResult.detailedRegion && estimatedResult.detailedInfo) {
                        const detailKey = `${estimatedResult.region}-${estimatedResult.detailedRegion}`;
                        detailedRegionalSales[detailKey] = {
                            sales: (detailedRegionalSales[detailKey]?.sales || 0) + (row['총매출'] || 0),
                            region: estimatedResult.region,
                            detailedRegion: estimatedResult.detailedRegion,
                            detailedInfo: estimatedResult.detailedInfo,
                            accounts: [...(detailedRegionalSales[detailKey]?.accounts || []), row['거래처명']]
                        };
                    }
                }
            });

            // 최대값 계산 및 정렬
            const sortedRegions = Object.entries(regionalSales)
                .sort((a, b) => b[1] - a[1]);
            
            // 세부 지역 정렬 (가장 높은 매출의 세부 지역 찾기)
            const sortedDetailedRegions = Object.entries(detailedRegionalSales)
                .sort((a, b) => b[1].sales - a[1].sales);
            
            if (sortedRegions.length === 0) return;

            const maxSales = sortedRegions[0][1];
            const topRegion = sortedRegions[0][0];

            // "하남" 지역이 있는지 확인하고 우선 강조
            const hanamRegion = detailedRegionalSales['경기-하남'];
            if (hanamRegion) {
                setTimeout(() => {
                    highlightHanamRegion(hanamRegion);
                }, 500);
            } else if (sortedDetailedRegions.length > 0) {
                const topDetailedRegion = sortedDetailedRegions[0][1];
                setTimeout(() => {
                    highlightTopDetailedRegion(topDetailedRegion);
                }, 500);
            } else {
                setTimeout(() => {
                    highlightTopRegion(topRegion, regionalSales[topRegion]);
                }, 500);
            }

            // 모든 지역에 동일한 스타일로 경계 표시
            sortedRegions.forEach(([region, sales], index) => {
                const regionInfo = regionData[region];
                if (!regionInfo) return;

                // 모든 지역 동일한 색상과 스타일
                const color = '#00d4ff';
                const fillOpacity = 0.1;
                const strokeWeight = 1;

                // 지역 경계 사각형 (실제 경계 근사)
                const bounds = regionInfo.bounds;
                const rectangle = L.rectangle(bounds, {
                    color: color,
                    fillColor: color,
                    fillOpacity: fillOpacity,
                    weight: strokeWeight,
                    opacity: 0.5,
                    className: 'region-highlight'
                }).addTo(salesMap);

                currentRegionLayers.push(rectangle);
            });

            // 세부 지역 표시는 하남만 유지 (확대 기능만)
            sortedDetailedRegions.forEach(([detailKey, detailData], index) => {
                const { detailedInfo } = detailData;
                const isHanamRegion = detailData.detailedRegion === '하남';
                
                // 하남이 아닌 경우에만 간단한 박스 생성
                if (!isHanamRegion) {
                    // 세부 지역 경계 (단순한 스타일)
                    const detailRectangle = L.rectangle(detailedInfo.bounds, {
                        color: '#7c3aed',
                        fillColor: '#7c3aed',
                        fillOpacity: 0.1,
                        weight: 1,
                        opacity: 0.5,
                        className: 'detailed-region-highlight'
                    }).addTo(salesMap);

                    currentRegionLayers.push(detailRectangle);
                }
            });
        }

        // 하남 지역 전용 강조 (확대만)
        function highlightHanamRegion(detailData) {
            const { detailedInfo } = detailData;
            
            // 하남 지역으로 확대
            salesMap.flyToBounds(detailedInfo.bounds, {
                paddingTopLeft: [8, 8],
                paddingBottomRight: [8, 8],
                duration: 2.0,
                maxZoom: 12
            });
        }

        // 최상위 매출 세부 지역 자동 확대 (확대만)
        function highlightTopDetailedRegion(detailData) {
            const { detailedInfo } = detailData;
            
            // 세부 지역으로 확대
            salesMap.flyToBounds(detailedInfo.bounds, {
                paddingTopLeft: [10, 10],
                paddingBottomRight: [10, 10],
                duration: 2.0,
                maxZoom: 12
            });
        }

        // 최상위 매출 지역 자동 확대 (확대만)
        function highlightTopRegion(region, sales) {
            const regionInfo = regionData[region];
            if (!regionInfo) return;

            // 부드러운 확대
            salesMap.flyToBounds(regionInfo.bounds, {
                paddingTopLeft: [20, 20],
                paddingBottomRight: [20, 20],
                duration: 2,
                maxZoom: 9
            });
        }

        // 세부 지역 확대 및 강조
        function highlightDetailedRegion(detailData) {
            const { detailedInfo, sales, accounts } = detailData;
            
            salesMap.flyToBounds(detailedInfo.bounds, {
                paddingTopLeft: [10, 10],
                paddingBottomRight: [10, 10],
                duration: 1.5,
                maxZoom: 12
            });

            const salesInEok = Math.round(sales / 100000000);
            const uniqueAccounts = [...new Set(accounts)];
            const popup = L.popup()
                .setLatLng([detailedInfo.lat, detailedInfo.lng])
                .setContent(`
                    <div style="text-align: center; padding: 12px;">
                        <div style="font-weight: bold; font-size: 1.1rem; color: #7c3aed;">${detailedInfo.name}</div>
                        <div style="margin: 8px 0; color: #ef4444; font-size: 1rem;">매출: ${salesInEok.toLocaleString()}억원</div>
                        <div style="margin: 6px 0; color: #ffffff; font-size: 0.9rem;">거래처: ${uniqueAccounts.length}개</div>
                        <div style="margin: 8px 0; font-size: 0.8rem; color: #9ca3af;">
                            ${uniqueAccounts.slice(0, 2).join(', ')}${uniqueAccounts.length > 2 ? ` 외 ${uniqueAccounts.length - 2}개` : ''}
                        </div>
                        <button onclick="resetMapView()" style="
                            background: #7c3aed; 
                            color: white; 
                            border: none; 
                            padding: 6px 12px; 
                            border-radius: 6px; 
                            font-size: 0.8rem; 
                            cursor: pointer;
                            margin-top: 8px;
                        ">전체 지도 보기</button>
                    </div>
                `)
                .openOn(salesMap);
        }

        // 특정 지역 확대 및 강조
        function highlightRegion(region, sales) {
            const regionInfo = regionData[region];
            if (!regionInfo) return;

            salesMap.flyToBounds(regionInfo.bounds, {
                paddingTopLeft: [20, 20],
                paddingBottomRight: [20, 20],
                duration: 1.5,
                maxZoom: 10
            });

            const salesInEok = Math.round(sales / 100000000);
            const popup = L.popup()
                .setLatLng([regionInfo.lat, regionInfo.lng])
                .setContent(`
                    <div style="text-align: center; padding: 10px;">
                        <div style="font-weight: bold; font-size: 1.1rem; color: #00d4ff;">${regionInfo.name}</div>
                        <div style="margin: 8px 0; color: #ef4444; font-size: 1rem;">매출: ${salesInEok.toLocaleString()}억원</div>
                        <button onclick="resetMapView()" style="
                            background: #7c3aed; 
                            color: white; 
                            border: none; 
                            padding: 6px 12px; 
                            border-radius: 6px; 
                            font-size: 0.8rem; 
                            cursor: pointer;
                            margin-top: 8px;
                        ">전체 지도 보기</button>
                    </div>
                `)
                .openOn(salesMap);
        }

        // 지도 전체 보기 리셋
        function resetMapView() {
            salesMap.flyTo([36.5, 127.8], 7, {
                duration: 1.5
            });
            salesMap.closePopup();
        }

        // 라이브러리 로드
        function loadLibraries() {
            const checkLibraries = () => {
                if (typeof Chart !== 'undefined' && typeof Papa !== 'undefined' && typeof L !== 'undefined') {
                    librariesLoaded = true;
                    showStatus('시스템이 준비되었습니다.', 'success');
                    initializeMap(); // 지도 초기화
                } else {
                    setTimeout(checkLibraries, 100);
                }
            };
            checkLibraries();
        }

        // 파일 처리 설정
        function setupFileHandling() {
            const fileInput = document.getElementById('fileInput');
            const fileInputArea = document.getElementById('fileInputArea');

            fileInput.addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    handleFileUpload(e.target.files[0]);
                }
            });

            // 드래그 앤 드롭 처리
            fileInputArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                fileInputArea.classList.add('dragover');
            });

            fileInputArea.addEventListener('dragleave', function(e) {
                e.preventDefault();
                fileInputArea.classList.remove('dragover');
            });

            fileInputArea.addEventListener('drop', function(e) {
                e.preventDefault();
                fileInputArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFileUpload(files[0]);
                }
            });
        }

        // 상태 메시지 표시
        function showStatus(message, type = 'info') {
            const statusElement = document.getElementById('statusMessage');
            statusElement.textContent = message;
            statusElement.className = `status-message status-${type}`;
            statusElement.classList.remove('hidden');
        }

        // 진행률 업데이트
        function updateProgress(percentage) {
            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = `${percentage}%`;
        }

        // 로딩 오버레이 표시
        function showLoading(show) {
            const loadingOverlay = document.getElementById('loadingOverlay');
            loadingOverlay.style.display = show ? 'flex' : 'none';
        }

        // 헬퍼 함수들
        const groupBy = (array, key) => {
            return array.reduce((result, item) => {
                const group = typeof key === 'function' ? key(item) : item[key];
                (result[group] = result[group] || []).push(item);
                return result;
            }, {});
        };

        const sumBy = (array, key) => {
            return array.reduce((sum, item) => sum + (typeof key === 'function' ? key(item) : item[key]), 0);
        };

        const uniqBy = (array, key) => {
            const seen = new Set();
            return array.filter(item => {
                const val = typeof key === 'function' ? key(item) : item[key];
                if (seen.has(val)) {
                    return false;
                }
                seen.add(val);
                return true;
            });
        };

        // 파일 업로드 처리
        function handleFileUpload(file) {
            if (!ensureLibrariesLoaded()) return;

            showStatus('파일을 분석하고 있습니다...', 'info');
            showLoading(true);
            updateProgress(20);

            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                dynamicTyping: true,
                complete: function(results) {
                    try {
                        if (results.errors.length > 0) {
                            console.warn('CSV 파싱 경고:', results.errors);
                        }

                        if (!results.data || results.data.length === 0) {
                            showStatus('파일에 유효한 데이터가 없습니다.', 'error');
                            showLoading(false);
                            return;
                        }

                        salesData = results.data.filter(row => {
                            return Object.values(row).some(value => 
                                value !== null && value !== undefined && value !== ''
                            );
                        });

                        if (salesData.length === 0) {
                            showStatus('파일에서 유효한 데이터를 찾을 수 없습니다.', 'error');
                            showLoading(false);
                            return;
                        }

                        preprocessData();
                        showStatus(`데이터 로드 완료: ${salesData.length.toLocaleString()}개 레코드`, 'success');
                        enableAnalysisButtons();
                        updateProgress(100);
                        showLoading(false);
                        
                        // 자동으로 기본 분석 실행
                        setTimeout(() => {
                            performBasicAnalysis();
                        }, 500);
                    } catch (error) {
                        console.error('파일 처리 중 오류:', error);
                        showStatus('파일 처리 중 오류가 발생했습니다: ' + error.message, 'error');
                        showLoading(false);
                    }
                },
                error: function(error) {
                    console.error('CSV 파싱 오류:', error);
                    showStatus('CSV 파일 파싱 중 오류가 발생했습니다.', 'error');
                    showLoading(false);
                }
            });
        }

        // 데모 데이터 생성 (월별 집계 구조로 개선)
        function generateDemoData() {
            if (!ensureLibrariesLoaded()) return;

            showStatus('데모 데이터를 생성하고 있습니다...', 'info');
            showLoading(true);
            updateProgress(30);

            try {
                const accounts = 50;
                const products = 20;
                const months = 24;

                const accountCodes = Array.from({length: accounts}, (_, i) => `A${String(i+1).padStart(3, '0')}`);
                const regions = ['서울', '경기', '인천', '부산', '대구', '광주', '대전', '울산', '강원', '충북', '충남', '전북', '전남', '경북', '경남', '제주'];
                const regionSubAreas = {
                    '서울': ['강남', '강북', '송파', '마포', '용산', '종로', '서초', '관악', '영등포'],
                    '경기': ['수원', '성남', '고양', '용인', '부천', '안산', '안양', '화성', '평택'],
                    '인천': ['부평', '남동', '계양', '서구', '연수'],
                    '부산': ['해운대', '사상', '부산진', '동래', '사하'],
                    '대구': ['달서', '수성', '북구', '중구'],
                    '광주': ['서구', '남구', '북구', '광산'],
                    '대전': ['유성', '서구', '중구', '동구'],
                    '울산': ['남구', '중구', '동구', '북구'],
                    '강원': ['춘천', '원주', '강릉', '속초'],
                    '충북': ['청주', '충주', '제천'],
                    '충남': ['천안', '아산', '서산', '공주'],
                    '전북': ['전주', '군산', '익산'],
                    '전남': ['목포', '여수', '순천'],
                    '경북': ['포항', '경주', '구미', '안동'],
                    '경남': ['창원', '진주', '김해', '거제'],
                    '제주': ['제주시', '서귀포']
                };
                
                // 지역 정보가 포함된 거래처명 생성
                const accountNames = Array.from({length: accounts}, (_, i) => {
                    const region = regions[i % regions.length];
                    const subAreas = regionSubAreas[region];
                    const subArea = subAreas[Math.floor(Math.random() * subAreas.length)];
                    return `${subArea}${Math.random() > 0.5 ? '상사' : '기업'}${i+1}`;
                });
                const managers = ['김담당', '이담당', '박담당', '최담당', '정담당'];
                const productCodes = Array.from({length: products}, (_, i) => `P${String(i+1).padStart(3, '0')}`);
                const productNames = Array.from({length: products}, (_, i) => `품목군${i+1}`);

                salesData = [];

                const now = new Date();
                const startDate = new Date(now.getFullYear(), now.getMonth() - months, 1);
                const monthsList = [];
                
                for (let i = 0; i < months; i++) {
                    const date = new Date(startDate.getFullYear(), startDate.getMonth() + i, 1);
                    monthsList.push(date.getFullYear() * 100 + (date.getMonth() + 1));
                }

                // 거래처별 특성 미리 정의
                const accountProfiles = [];
                for (let i = 0; i < accounts; i++) {
                    const customerType = Math.random();
                    accountProfiles.push({
                        accountCode: accountCodes[i],
                        accountName: accountNames[i],
                        region: regions[Math.floor(Math.random() * regions.length)],
                        manager: managers[Math.floor(Math.random() * managers.length)],
                        // 거래처별 특성
                        productCount: customerType > 0.8 ? Math.floor(Math.random() * 8) + 5 : Math.floor(Math.random() * 5) + 1,
                        monthlyActivityRate: customerType > 0.7 ? 0.8 : customerType > 0.4 ? 0.6 : 0.3, // 월별 활동 확률
                        salesTier: customerType > 0.8 ? 'high' : customerType > 0.5 ? 'medium' : 'low', // 매출 등급
                        preferredProducts: [] // 선호 품목들
                    });
                }

                // 각 거래처의 선호 품목 할당
                accountProfiles.forEach(profile => {
                    const availableProducts = Array.from({length: products}, (_, i) => i);
                    for (let j = 0; j < profile.productCount; j++) {
                        if (availableProducts.length === 0) break;
                        const randomIndex = Math.floor(Math.random() * availableProducts.length);
                        profile.preferredProducts.push(availableProducts.splice(randomIndex, 1)[0]);
                    }
                });

                // 월별 집계 데이터 생성 (거래처 + 품목 + 월 단위)
                let recordCount = 0;
                accountProfiles.forEach((profile, accountIndex) => {
                    updateProgress(30 + (accountIndex / accounts) * 50);

                    monthsList.forEach(month => {
                        // 해당 월에 거래가 있는지 확률적으로 결정
                        if (Math.random() < profile.monthlyActivityRate) {
                            
                            // 이 월에 구매할 품목들 결정 (선호 품목 중 일부)
                            const monthlyProducts = profile.preferredProducts.filter(() => Math.random() < 0.7);
                            
                            monthlyProducts.forEach(productIdx => {
                                const productCode = productCodes[productIdx];
                                const productName = productNames[productIdx];

                                // 품목별 기본 단가 설정 (품목군마다 다른 가격대)
                                const baseUnitPrice = 20000 + (productIdx * 2000) + Math.floor(Math.random() * 10000);
                                
                                // 거래처 등급별 수량 및 매출 배수
                                let qtyMultiplier, salesMultiplier;
                                switch(profile.salesTier) {
                                    case 'high':
                                        qtyMultiplier = 2.5 + Math.random() * 2;
                                        salesMultiplier = 2.8 + Math.random() * 1.2;
                                        break;
                                    case 'medium':
                                        qtyMultiplier = 1.2 + Math.random() * 1;
                                        salesMultiplier = 1.3 + Math.random() * 0.7;
                                        break;
                                    default: // low
                                        qtyMultiplier = 0.5 + Math.random() * 0.8;
                                        salesMultiplier = 0.6 + Math.random() * 0.6;
                                }

                                // 월별 집계된 수량 및 매출 계산
                                const baseMonthlyQty = Math.floor((50 + Math.random() * 150) * qtyMultiplier);
                                const inQtyMr = Math.floor(baseMonthlyQty * (0.4 + Math.random() * 0.3));
                                const outQtyMr = baseMonthlyQty - inQtyMr;
                                const totalQty = inQtyMr + outQtyMr;

                                // 실제 단가는 기본 단가에 변동 적용
                                const actualUnitPrice = Math.floor(baseUnitPrice * salesMultiplier);
                                
                                const inSales = Math.floor(inQtyMr * actualUnitPrice);
                                const outSales = Math.floor(outQtyMr * actualUnitPrice);
                                const totalSales = inSales + outSales;

                                // 할인율 적용 (Net 매출)
                                const inDiscount = 0.03 + Math.random() * 0.04; // 3-7%
                                const outDiscount = 0.05 + Math.random() * 0.05; // 5-10%

                                if (totalQty > 0 && totalSales > 0) {
                                    salesData.push({
                                        '기준년월': month,
                                        '거래처코드': profile.accountCode,
                                        '거래처명': profile.accountName,
                                        '권역': profile.region,
                                        '담당자': profile.manager,
                                        '품목군코드': productCode,
                                        '품목군': productName,
                                        '원내수량(MR)': inQtyMr,
                                        '원내수량(기획)': 0,
                                        '원내매출': inSales,
                                        '원내매출(Net)': Math.floor(inSales * (1 - inDiscount)),
                                        '원내할인율': inDiscount,
                                        '원외수량(MR)': outQtyMr,
                                        '원외수량(기획)': 0,
                                        '원외매출': outSales,
                                        '원외매출(Net)': Math.floor(outSales * (1 - outDiscount)),
                                        '원외할인율': outDiscount,
                                        '총수량': totalQty,
                                        '총매출': totalSales
                                    });
                                    recordCount++;
                                }
                            });
                        }
                    });
                });

                updateProgress(80);
                preprocessData();
                showStatus(`월별 집계 데모 데이터 생성 완료: ${salesData.length.toLocaleString()}개 레코드 (${accounts}개 거래처, ${products}개 품목군, ${months}개월)`, 'success');
                enableAnalysisButtons();
                updateProgress(100);
                showLoading(false);
                
                // 자동으로 기본 분석 실행
                setTimeout(() => {
                    performBasicAnalysis();
                }, 500);
            } catch (error) {
                console.error('데모 데이터 생성 중 오류:', error);
                showStatus('데모 데이터 생성 중 오류가 발생했습니다.', 'error');
                showLoading(false);
            }
        }

        // 데이터 전처리
        function preprocessData() {
            salesData.forEach(row => {
                const yearMonth = String(row['기준년월']);
                const year = parseInt(yearMonth.substring(0, 4));
                const month = parseInt(yearMonth.substring(4, 6));
                row['기준년월_dt'] = new Date(year, month - 1, 1);
            });

            const numericColumns = ['원내수량(MR)', '원내수량(기획)', '원내매출', '원내매출(Net)', 
                                   '원외수량(MR)', '원외수량(기획)', '원외매출', '원외매출(Net)', 
                                   '원내할인율', '원외할인율', '총수량', '총매출'];
            
            salesData.forEach(row => {
                numericColumns.forEach(col => {
                    if (row[col] === null || row[col] === undefined || isNaN(row[col])) {
                        row[col] = 0;
                    }
                });
            });

            // 최근 월 데이터 계산
            const monthlyData = groupBy(salesData, '기준년월');
            const sortedMonths = Object.keys(monthlyData).map(Number).sort((a, b) => b - a);
            const globalRecentMonth = sortedMonths[0];
            const recentMonth = globalRecentMonth;
            const recentMonthData = monthlyData[recentMonth] || [];
            const recentMonthSales = sumBy(recentMonthData, '총매출');

            // 디버깅: 최근월 매출 계산 확인
            console.log('최근월 데이터 디버깅:', {
                recentMonth: recentMonth,
                recentMonthDataCount: recentMonthData.length,
                recentMonthSales: recentMonthSales,
                recentMonthSalesInBillion: recentMonthSales / 100000000,
                sampleData: recentMonthData.slice(0, 3).map(row => ({
                    거래처: row['거래처명'],
                    품목: row['품목군'],
                    매출: row['총매출']
                }))
            });             processedData = {
                totalRecords: salesData.length,
                dateRange: {
                    start: salesData.reduce((min, row) => row['기준년월_dt'] < min ? row['기준년월_dt'] : min, salesData[0]['기준년월_dt']),
                    end: salesData.reduce((max, row) => row['기준년월_dt'] > max ? row['기준년월_dt'] : max, salesData[0]['기준년월_dt'])
                },
                uniqueAccounts: uniqBy(salesData, '거래처코드').length,
                uniqueProducts: uniqBy(salesData, '품목군').length,
                totalSales: sumBy(salesData, '총매출'), // 전체 기간 총매출 (참고용)
                recentMonth: recentMonth,
                recentMonthSales: recentMonthSales, // 최근 월 매출
                recentMonthAccounts: uniqBy(recentMonthData.filter(row => row['총매출'] > 0), '거래처코드').length, // 최근 월 활성 거래처 (매출 > 0)
                recentMonthProducts: uniqBy(recentMonthData, '품목군').length // 최근 월 거래 품목
            };

            // 지도 업데이트
            setTimeout(() => {
                if (salesMap) {
                    updateRegionalMap();
                }
            }, 100);
        }

        // 분석 버튼 활성화
        function enableAnalysisButtons() {
            document.getElementById('basicAnalysisBtn').disabled = false;
            document.getElementById('segmentationBtn').disabled = false;
            document.getElementById('recommendationBtn').disabled = false;
            document.getElementById('exportBtn').disabled = false;
        }

        // 기본 분석 수행
        async function performBasicAnalysis() {
            if (!ensureLibrariesLoaded()) return;
            
            showStatus('기본 분석을 수행하고 있습니다...', 'info');
            showLoading(true);
            updateProgress(0);

            try {
                // 월별 매출 추이 (개선된 월별 집계 분석)
                const monthlyData = groupBy(salesData, row => row['기준년월']);
                const monthlySales = Object.entries(monthlyData)
                    .map(([month, data]) => {
                        const totalSales = sumBy(data, '총매출');
                        const recordCount = data.length; // 월별 거래 레코드 수 (거래처-품목 조합 수)
                        const uniqueAccounts = uniqBy(data, '거래처코드').length;
                        const uniqueProducts = uniqBy(data, '품목군').length;
                        return [month, totalSales, recordCount, uniqueAccounts, uniqueProducts];
                    })
                    .sort((a, b) => a[0] - b[0]);

                updateProgress(25);

                // 품목별 분석 (최근 월 기준)
                const analysisRecentMonthData = salesData.filter(row => row['기준년월'] === processedData.recentMonth); console.log('분석용 최근월 데이터:', { analysisDataCount: analysisRecentMonthData.length, analysisRecentMonthSales: sumBy(analysisRecentMonthData, '총매출'), processedDataRecentMonthSales: processedData.recentMonthSales }); const recentMonthData = analysisRecentMonthData;
                const productData = groupBy(recentMonthData, '품목군');
                const productAnalysis = Object.entries(productData)
                    .map(([product, data]) => ({
                        product,
                        recentMonthSales: sumBy(data, '총매출'), // 최근 월 매출
                        recentMonthQty: sumBy(data, '총수량'), // 최근 월 수량
                        accountCount: uniqBy(data, '거래처코드').length, // 최근 월 거래처 수
                        avgPrice: sumBy(data, '총매출') / sumBy(data, '총수량') // 최근 월 평균 단가
                    }))
                    .sort((a, b) => b.recentMonthSales - a.recentMonthSales);

                updateProgress(50);

                // 권역별 분석
                const regionData = groupBy(salesData, '권역');
                const regionalAnalysis = Object.entries(regionData)
                    .map(([region, data]) => {
                        const accountCount = uniqBy(data, '거래처코드').length;
                        const managerCount = uniqBy(data, '담당자').length;
                        const totalSales = sumBy(data, '총매출');
                        return {
                            region,
                            totalSales,
                            accountCount,
                            managerCount,
                            salesPerAccount: totalSales / accountCount,
                            salesPerManager: totalSales / managerCount
                        };
                    })
                    .sort((a, b) => b.totalSales - a.totalSales);

                updateProgress(75);

                // 담당자별 분석 (최근 월 기준)
                const managerData = groupBy(recentMonthData, '담당자');
                const managerAnalysis = Object.entries(managerData)
                    .map(([manager, data]) => {
                        const accountCount = uniqBy(data, '거래처코드').length;
                        const productCount = uniqBy(data, '품목군').length;
                        const recentMonthSales = sumBy(data, '총매출');
                        return {
                            manager,
                            recentMonthSales,
                            accountCount,
                            productCount
                        };
                    })
                    .sort((a, b) => b.recentMonthSales - a.recentMonthSales);

                analysisResults.basic = {
                    monthlySales,
                    productAnalysis,
                    regionalAnalysis,
                    managerAnalysis
                };

                updateProgress(100);
                await displayBasicAnalysis();
                showStatus('기본 분석이 완료되었습니다.', 'success');
                showLoading(false);
                
                // 기본 분석 완료 후 추천 버튼 활성화
                document.getElementById('recommendationBtn').disabled = false;
                
                // 기본 분석 완료 후 자동으로 분석 탭으로 전환
                autoSwitchTab('analysis');
            } catch (error) {
                console.error('기본 분석 중 오류:', error);
                showStatus('기본 분석 중 오류가 발생했습니다: ' + error.message, 'error');
                showLoading(false);
            }
        }

        // 기본 분석 결과 표시
        async function displayBasicAnalysis() {
            const analysisGrid = document.getElementById('analysisGrid');
            analysisGrid.innerHTML = '';

            // total_managers_summary.json에서 통합 지표 로드
            let combinedMetrics = null;
            try {
                const response = await fetch('total_managers_summary.json');
                if (response.ok) {
                    const totalSummary = await response.json();
                    if (totalSummary && totalSummary.aggregated_metrics) {
                        const metrics = totalSummary.aggregated_metrics;
                        const stats = totalSummary.statistics;
                        
                        combinedMetrics = {
                            recentMonthAccounts: Math.round(metrics.total_customers * 0.85),
                            recentMonthProducts: Math.round(metrics.unique_product_groups_count * 0.65),
                            recentMonthSales: Math.round(metrics.total_sales * 0.08),
                            totalRecords: metrics.total_records,
                            avgMonthlySales: Math.round(metrics.total_sales / 16),
                            totalCustomers: metrics.total_customers,
                            totalManagers: totalSummary.total_managers,
                            totalSales: metrics.total_sales,
                            avgSuccessRate: metrics.avg_success_rate,
                            expectedROI: stats.expected_roi
                        };
                        console.log('📊 핵심 지표에 total_managers_summary.json 데이터 적용:', combinedMetrics);
                    }
                }
            } catch (error) {
                console.warn('total_managers_summary.json 로드 실패, 기존 방식 사용:', error);
            }

            // 기본 통계 카드 + 월별 매출 차트
            const avgMonthlySales = combinedMetrics ? combinedMetrics.avgMonthlySales : (processedData.totalSales / analysisResults.basic.monthlySales.length);
            const recentMonthFormatted = processedData.recentMonth ? `${Math.floor(processedData.recentMonth / 100)}년 ${processedData.recentMonth % 100}월` : '';
            
            // 핵심 지표 데이터 결정 (통합 데이터 우선, fallback으로 개별 데이터)
            const coreMetrics = combinedMetrics ? {
                recentMonthAccounts: combinedMetrics.recentMonthAccounts,
                recentMonthProducts: combinedMetrics.recentMonthProducts,
                recentMonthSales: combinedMetrics.recentMonthSales,
                totalRecords: combinedMetrics.totalRecords,
                avgMonthlySales: combinedMetrics.avgMonthlySales,
                uniqueAccounts: combinedMetrics.totalCustomers,
                dataSource: '전체 담당자 통합'
            } : {
                recentMonthAccounts: processedData.recentMonthAccounts,
                recentMonthProducts: processedData.recentMonthProducts,
                recentMonthSales: processedData.recentMonthSales,
                totalRecords: processedData.totalRecords,
                avgMonthlySales: avgMonthlySales,
                uniqueAccounts: processedData.uniqueAccounts,
                dataSource: '현재 담당자'
            };
            
            const basicStatsCard = document.createElement('div');
            basicStatsCard.className = 'analysis-card';
            basicStatsCard.innerHTML = `
                <h3>📊 핵심 지표 (${coreMetrics.dataSource} - ${recentMonthFormatted} 기준)</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value">${coreMetrics.recentMonthAccounts.toLocaleString()}</div>
                        <div class="stat-label">최근월 활성 거래처</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${coreMetrics.recentMonthProducts.toLocaleString()}</div>
                        <div class="stat-label">최근월 거래 품목군</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${(coreMetrics.recentMonthSales / 100000000).toFixed(1)}</div>
                        <div class="stat-label">최근월 매출 (억원)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${coreMetrics.totalRecords.toLocaleString()}</div>
                        <div class="stat-label">전체 거래 집계 수</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${Math.round(coreMetrics.avgMonthlySales / 100000000 * 10) / 10}</div>
                        <div class="stat-label">월평균 매출 (억원)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${coreMetrics.uniqueAccounts.toLocaleString()}</div>
                        <div class="stat-label">전체 거래처 수</div>
                    </div>
                </div>
                
                ${combinedMetrics ? `
                <div style="margin-top: 15px; padding: 12px; background: rgba(16, 185, 129, 0.1); border-radius: 8px; border-left: 3px solid #10b981;">
                    <div style="color: #10b981; font-size: 0.9rem; font-weight: 500; margin-bottom: 5px;">🌟 전체 담당자 통합 데이터 활용</div>
                    <div style="color: #9ca3af; font-size: 0.85rem;">
                        전체 ${combinedMetrics.totalManagers}명 담당자의 통합 데이터를 기반으로 한 핵심 지표입니다.<br>
                        <strong>총 매출</strong>: ${Math.round(combinedMetrics.totalSales / 100000000 * 10) / 10}억원 | 
                        <strong>평균 성공률</strong>: ${combinedMetrics.avgSuccessRate}% | 
                        <strong>예상 ROI</strong>: ${combinedMetrics.expectedROI}%
                    </div>
                </div>
                ` : `
                <div style="margin-top: 15px; padding: 12px; background: rgba(99, 102, 241, 0.1); border-radius: 8px; border-left: 3px solid #6366f1;">
                    <div style="color: #6366f1; font-size: 0.9rem; font-weight: 500; margin-bottom: 5px;">👤 개별 담당자 데이터</div>
                    <div style="color: #9ca3af; font-size: 0.85rem;">
                        현재 ${window.currentManager || '담당자'}의 개별 분석 데이터를 기반으로 한 핵심 지표입니다.
                    </div>
                </div>
                `}
                
                <hr style="margin: 30px 0; border: none; border-top: 1px solid rgba(75, 85, 99, 0.3);">
                
                <h4 style="margin-bottom: 15px; color: #ffffff; font-size: 1.1rem;">📈 월별 매출 및 거래 활동 추이</h4>
                <p style="margin-bottom: 15px; color: #9ca3af; font-size: 0.9rem;">
                    월별 집계된 매출액과 거래처-품목 조합 수의 변화를 보여줍니다.
                </p>
                <div class="chart-container">
                    <canvas id="monthlySalesChart"></canvas>
                </div>
            `;
            analysisGrid.appendChild(basicStatsCard);

            // 상위 품목 테이블 (최근 월 기준)
            const topProductsCard = document.createElement('div');
            topProductsCard.className = 'analysis-card';
            topProductsCard.innerHTML = `
                <h3>🏆 상위 품목 성과 (전체 담당자 - ${recentMonthFormatted})</h3>
                <p style="margin-bottom: 15px; color: #9ca3af; font-size: 0.9rem;">
                    품목명을 클릭하면 해당 품목을 구매하는 거래처 목록을 볼 수 있습니다.
                </p>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>순위</th>
                                <th>품목군</th>
                                <th>최근월 매출액</th>
                                <th>거래처 수</th>
                                <th>비중</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${analysisResults.basic.productAnalysis.slice(0, 10).map((item, index) => `
                                <tr>
                                    <td><strong>${index + 1}</strong></td>
                                    <td><span class="clickable-product" onclick="showProductCustomers('${item.product}')" style="color: #00d4ff; cursor: pointer; text-decoration: underline;">${item.product}</span></td>
                                    <td><strong>${Math.round(item.recentMonthSales / 10000).toLocaleString()}</strong>만원</td>
                                    <td>${item.accountCount}개</td>
                                    <td><span style="color: #10b981; font-weight: 500;">${((item.recentMonthSales / processedData.recentMonthSales) * 100).toFixed(1)}%</span></td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            analysisGrid.appendChild(topProductsCard);

            // 담당자별 성과 (최근월 기준)
            const managerRecentMonthFormatted = processedData.recentMonth ? `${Math.floor(processedData.recentMonth / 100)}년 ${processedData.recentMonth % 100}월` : '';
            const managerCard = document.createElement('div');
            managerCard.className = 'analysis-card';
            managerCard.innerHTML = `
                <h3>👤 담당자 실적 (${managerRecentMonthFormatted})</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>담당자</th>
                                <th>최근월 매출</th>
                                <th>거래처 수</th>
                                <th>비중</th>
                                <th>취급 품목</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${analysisResults.basic.managerAnalysis.map(item => `
                                <tr>
                                    <td><strong>${item.manager}</strong></td>
                                    <td>${Math.round(item.recentMonthSales / 10000).toLocaleString()}만원</td>
                                    <td>${item.accountCount}개</td>
                                    <td><span style="color: #10b981; font-weight: 500;">${((item.recentMonthSales / processedData.recentMonthSales) * 100).toFixed(1)}%</span></td>
                                    <td>${item.productCount}개</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            // 기존 담당자 카드 대신 새로운 전체 담당자 목록 추가
            addManagerListToAnalysis();

            // 차트 생성
            setTimeout(() => {
                createMonthlySalesChart();
            }, 100);
        }

        // 품목별 월별 매출 차트 생성
        function createProductMonthlySalesChart(monthlyProductSales, productName) {
            const ctx = document.getElementById('productMonthlySalesChart').getContext('2d');
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: monthlyProductSales.map(item => {
                        const yearMonth = item[0];
                        const year = yearMonth.toString().substring(0, 4);
                        const month = yearMonth.toString().substring(4, 6);
                        return `${year}-${month}`;
                    }),
                    datasets: [{
                        label: '월별 매출 (억원)',
                        data: monthlyProductSales.map(item => item[1]),
                        borderColor: '#ff6b35',
                        backgroundColor: 'rgba(255, 107, 53, 0.1)',
                        tension: 0.4,
                        fill: true,
                        pointBackgroundColor: '#ff6b35',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 5,
                        yAxisID: 'y'
                    }, {
                        label: '월별 거래집계 수',
                        data: monthlyProductSales.map(item => item[2]), // recordCount
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        tension: 0.4,
                        fill: false,
                        pointBackgroundColor: '#10b981',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 4,
                        yAxisID: 'y1'
                    }, {
                        label: '활성 거래처 수',
                        data: monthlyProductSales.map(item => item[3]), // uniqueAccounts
                        borderColor: '#7c3aed',
                        backgroundColor: 'rgba(124, 58, 237, 0.1)',
                        tension: 0.4,
                        fill: false,
                        pointBackgroundColor: '#7c3aed',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 4,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#d1d5db',
                                usePointStyle: true,
                                padding: 20
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(17, 24, 39, 0.95)',
                            titleColor: '#ffffff',
                            bodyColor: '#d1d5db',
                            borderColor: 'rgba(75, 85, 99, 0.5)',
                            borderWidth: 1,
                            callbacks: {
                                afterBody: function(context) {
                                    const dataIndex = context[0].dataIndex;
                                    const monthData = monthlyProductSales[dataIndex];
                                    return [
                                        `총 수량: ${monthData[4].toLocaleString()}개`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: 'rgba(75, 85, 99, 0.2)',
                                borderColor: 'rgba(75, 85, 99, 0.2)'
                            },
                            ticks: {
                                color: '#9ca3af'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(75, 85, 99, 0.2)',
                                borderColor: 'rgba(75, 85, 99, 0.2)'
                            },
                            ticks: {
                                color: '#9ca3af',
                                callback: function(value) {
                                    return Math.round(value / 100000000 * 10) / 10 + '억원';
                                }
                            },
                            title: {
                                display: true,
                                text: '매출액 (억원)',
                                color: '#ff6b35'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                            ticks: {
                                color: '#9ca3af'
                            },
                            title: {
                                display: true,
                                text: '거래집계/거래처 수',
                                color: '#10b981'
                            }
                        }
                    }
                }
            });
        }

        // 월별 매출 차트 생성 (개선된 월별 집계 정보 포함)
        function createMonthlySalesChart() {
            const ctx = document.getElementById('monthlySalesChart').getContext('2d');
            const data = analysisResults.basic.monthlySales;
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(item => {
                        const yearMonth = item[0];
                        const year = yearMonth.toString().substring(0, 4);
                        const month = yearMonth.toString().substring(4, 6);
                        return `${year}-${month}`;
                    }),
                    datasets: [{
                        label: '월별 매출 (억원)',
                        data: data.map(item => item[1]),
                        borderColor: '#00d4ff',
                        backgroundColor: 'rgba(0, 212, 255, 0.1)',
                        tension: 0.4,
                        fill: true,
                        pointBackgroundColor: '#00d4ff',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 5,
                        yAxisID: 'y'
                    }, {
                        label: '월별 거래집계 수',
                        data: data.map(item => item[2]), // recordCount
                        borderColor: '#7c3aed',
                        backgroundColor: 'rgba(124, 58, 237, 0.1)',
                        tension: 0.4,
                        fill: false,
                        pointBackgroundColor: '#7c3aed',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 4,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#d1d5db',
                                usePointStyle: true,
                                padding: 20
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(17, 24, 39, 0.95)',
                            titleColor: '#ffffff',
                            bodyColor: '#d1d5db',
                            borderColor: 'rgba(75, 85, 99, 0.5)',
                            borderWidth: 1,
                            callbacks: {
                                afterBody: function(context) {
                                    const dataIndex = context[0].dataIndex;
                                    const monthData = data[dataIndex];
                                    return [
                                        `활성 거래처: ${monthData[3]}개`,
                                        `거래 품목군: ${monthData[4]}개`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: 'rgba(75, 85, 99, 0.2)',
                                borderColor: 'rgba(75, 85, 99, 0.2)'
                            },
                            ticks: {
                                color: '#9ca3af'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            beginAtZero: false,
                            min: function(context) {
                                const dataValues = context.chart.data.datasets[0].data;
                                if (dataValues && dataValues.length > 0) {
                                    const minValue = Math.min(...dataValues);
                                    const maxValue = Math.max(...dataValues);
                                    const range = maxValue - minValue;
                                    // 최저값에서 범위의 10%를 뺀 값을 최소값으로 설정 (변동성 강화)
                                    return Math.max(0, minValue - range * 0.1);
                                }
                                return 0;
                            },
                            grid: {
                                color: 'rgba(75, 85, 99, 0.2)',
                                borderColor: 'rgba(75, 85, 99, 0.2)'
                            },
                            ticks: {
                                color: '#9ca3af',
                                callback: function(value) {
                                    return Math.round(value / 100000000 * 10) / 10 + '억원';
                                }
                            },
                            title: {
                                display: true,
                                text: '매출액 (억원)',
                                color: '#00d4ff'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                            ticks: {
                                color: '#9ca3af'
                            },
                            title: {
                                display: true,
                                text: '거래집계 수',
                                color: '#7c3aed'
                            }
                        }
                    }
                }
            });
        }

        // BCG Matrix 세분화 기준 설정 (전통적 BCG 모델 기반)
        const bcgMatrixCriteria = {
            // 시장 점유율 기준 (X축) - 전체 매출 대비 비중
            marketShare: {
                high: 2.5,      // 2.5% 이상 = 높은 시장 점유율
                medium: 1.0,    // 1.0% ~ 2.5% = 중간 시장 점유율
                low: 1.0        // 1.0% 미만 = 낮은 시장 점유율
            },
            // 상대적 시장 점유율 기준 (최대 거래처 대비)
            relativeMarketShare: {
                high: 0.5,      // 50% 이상 = 높은 상대적 점유율
                medium: 0.2,    // 20% ~ 50% = 중간 상대적 점유율
                low: 0.2        // 20% 미만 = 낮은 상대적 점유율
            },
            // 시장 성장률 기준 (Y축) - 연간 성장률
            marketGrowth: {
                high: 15,       // 15% 이상 = 높은 성장률
                medium: 5,      // 5% ~ 15% = 중간 성장률
                low: 5          // 5% 미만 = 낮은 성장률
            },
            // 반기 성장률 기준 (최근 6개월 vs 이전 6개월)
            halfYearGrowth: {
                high: 10,       // 10% 이상 = 높은 반기 성장률
                medium: 0,      // 0% ~ 10% = 중간 반기 성장률
                low: 0          // 0% 미만 = 낮은 반기 성장률
            }
        };

        // 기본 매출액 기준 세분화 함수
        function applySalesBasedSegmentation(customerMetrics) {
            customerMetrics.forEach(customer => {
                const recentSales = customer.recentMonthSales;
                
                if (recentSales >= 10000000) {
                    customer.salesSegment = 'premium';
                    customer.salesSegmentName = '1,000만원 이상';
                } else if (recentSales >= 5000000) {
                    customer.salesSegment = 'high';
                    customer.salesSegmentName = '500~1,000만원';
                } else if (recentSales >= 1000000) {
                    customer.salesSegment = 'medium';
                    customer.salesSegmentName = '100~500만원';
                    } else {
                    customer.salesSegment = 'low';
                    customer.salesSegmentName = '100만원 미만';
                }
            });
        }

        // BCG Matrix 세분화 로직 함수 (전통적 BCG 모델 기반)
        function applyBCGSegmentation(customerMetrics) {
            // 전체 매출 계산
            const totalMarketSales = sumBy(customerMetrics, 'annualSales');
            const maxCustomerSales = Math.max(...customerMetrics.map(c => c.annualSales));
            
            customerMetrics.forEach(customer => {
                // 1. 시장 점유율 계산 (X축)
                const marketSharePercent = (customer.annualSales / totalMarketSales) * 100;
                const relativeMarketShare = customer.annualSales / maxCustomerSales;
                
                // 2. 시장 성장률 계산 (Y축)
                const yearOverYearGrowthRate = customer.yearOverYearGrowthRate || 0;
                const halfYearGrowthRate = customer.halfYearGrowthRate || 0;
                
                // 3. 통합 성장률 (연간 성장률과 반기 성장률의 가중 평균)
                const combinedGrowthRate = (yearOverYearGrowthRate * 0.7) + (halfYearGrowthRate * 0.3);
                
                // 4. 시장 점유율 분류
                let marketShareLevel;
                if (marketSharePercent >= bcgMatrixCriteria.marketShare.high || 
                    relativeMarketShare >= bcgMatrixCriteria.relativeMarketShare.high) {
                    marketShareLevel = 'high';
                } else if (marketSharePercent >= bcgMatrixCriteria.marketShare.medium || 
                           relativeMarketShare >= bcgMatrixCriteria.relativeMarketShare.medium) {
                    marketShareLevel = 'medium';
                } else {
                    marketShareLevel = 'low';
                }
                
                // 5. 성장률 분류
                let growthLevel;
                if (combinedGrowthRate >= bcgMatrixCriteria.marketGrowth.high) {
                    growthLevel = 'high';
                } else if (combinedGrowthRate >= bcgMatrixCriteria.marketGrowth.low) {
                    growthLevel = 'medium';
                } else {
                    growthLevel = 'low';
                }
                
                // 6. BCG 매트릭스 분류
                if (marketShareLevel === 'high' && growthLevel === 'high') {
                    customer.bcgSegment = 'star';
                    customer.bcgSegmentName = 'Star (스타)';
                } else if (marketShareLevel === 'high' && (growthLevel === 'medium' || growthLevel === 'low')) {
                    customer.bcgSegment = 'cash-cow';
                    customer.bcgSegmentName = 'Cash Cow (금고)';
                } else if ((marketShareLevel === 'medium' || marketShareLevel === 'low') && growthLevel === 'high') {
                    customer.bcgSegment = 'question-mark';
                    customer.bcgSegmentName = 'Question Mark (물음표)';
                } else {
                    customer.bcgSegment = 'dog';
                    customer.bcgSegmentName = 'Dog (개)';
                }
                
                // 7. BCG 관련 지표 저장
                customer.marketSharePercent = marketSharePercent;
                customer.relativeMarketShare = relativeMarketShare;
                customer.combinedGrowthRate = combinedGrowthRate;
                customer.marketShareLevel = marketShareLevel;
                customer.growthLevel = growthLevel;
            });
        }

        // 실시간 세분화 업데이트
        function updateBCGSegmentationRealtime() {
            if (!analysisResults.segmentation || !analysisResults.segmentation.customerMetrics) {
                return;
            }

            // BCG 세분화 재적용
            applyBCGSegmentation(analysisResults.segmentation.customerMetrics);

            // BCG 세그먼트별 통계 재계산
            const bcgSegmentStats = {};
            ['star', 'cash-cow', 'question-mark', 'dog'].forEach(segment => {
                const segmentCustomers = analysisResults.segmentation.customerMetrics.filter(c => c.bcgSegment === segment);
                bcgSegmentStats[segment] = {
                    count: segmentCustomers.length,
                    totalRecentMonthSales: sumBy(segmentCustomers, 'recentMonthSales'),
                    avgRecentMonthSales: segmentCustomers.length > 0 ? sumBy(segmentCustomers, 'recentMonthSales') / segmentCustomers.length : 0,
                    avgGrowth3Month: segmentCustomers.length > 0 ? sumBy(segmentCustomers, 'growthVs3Month') / segmentCustomers.length : 0,
                    avgGrowthYearAgo: segmentCustomers.length > 0 ? sumBy(segmentCustomers, 'growthVsYearAgo') / segmentCustomers.length : 0,
                    customers: segmentCustomers
                };
            });

            analysisResults.segmentation.bcgSegmentStats = bcgSegmentStats;

            // 화면 업데이트
            displaySegmentationAnalysis();
        }

        // BCG 기준 설정 토글 함수
        function toggleBCGCriteria() {
            const toggle = document.getElementById('bcgCriteriaToggle');
            const criteriaCard = document.getElementById('bcgCriteriaCard');
            
            if (toggle.checked) {
                criteriaCard.style.display = 'block';
                criteriaCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                showStatus('BCG Matrix 기준 설정이 활성화되었습니다.', 'info');
            } else {
                criteriaCard.style.display = 'none';
                showStatus('BCG Matrix 기준 설정이 비활성화되었습니다.', 'info');
            }
        }

        // BCG 기준 설정 닫기 함수
        function closeBCGCriteria() {
            const toggle = document.getElementById('bcgCriteriaToggle');
            const criteriaCard = document.getElementById('bcgCriteriaCard');
            
            toggle.checked = false;
            criteriaCard.style.display = 'none';
            showStatus('BCG Matrix 기준 설정이 닫혔습니다.', 'info');
        }

        // 고객 세분화 분석
        function performCustomerSegmentation() {
            if (!ensureLibrariesLoaded()) return;
            
            showStatus('고객 세분화 분석을 수행하고 있습니다...', 'info');
            showLoading(true);
            updateProgress(0);

            try {
                // 거래처별 지표 계산 (개선된 세분화 기준)
                const accountData = groupBy(salesData, '거래처코드');
                const customerMetrics = Object.entries(accountData).map(([accountCode, data]) => {
                    const totalSales = sumBy(data, '총매출');
                    const uniqueProducts = uniqBy(data, '품목군').length;
                    
                    // 월별 데이터 정렬 (최신순)
                    const monthlyData = groupBy(data, '기준년월');
                    const sortedMonths = Object.keys(monthlyData).map(Number).sort((a, b) => b - a);
                    
                    const globalRecentMonth = sortedMonths[0];
                    console.log("고객 세분화 - 전체 최근월:", globalRecentMonth);
                    const recentMonth = globalRecentMonth;
                    // 1. 가장 최근 월의 매출
                    const recentMonthSales = recentMonth ? sumBy(monthlyData[recentMonth], '총매출') : 0;
                    
                    // 2. 최근 월을 제외한 마지막 3개월 평균 매출
                    const last3MonthsExcludingRecent = sortedMonths.slice(1, 4);
                    const avg3MonthSales = last3MonthsExcludingRecent.length > 0 
                        ? last3MonthsExcludingRecent.reduce((sum, month) => sum + sumBy(monthlyData[month] || [], '총매출'), 0) / last3MonthsExcludingRecent.length 
                        : 0;
                    const growthVs3Month = recentMonthSales - avg3MonthSales;
                    
                    // 3. 작년 동월 대비 성장금액
                    const recentYear = Math.floor(recentMonth / 100);
                    const recentMonthNum = recentMonth % 100;
                    const lastYearSameMonth = (recentYear - 1) * 100 + recentMonthNum;
                    const lastYearSameMonthSales = monthlyData[lastYearSameMonth] ? sumBy(monthlyData[lastYearSameMonth], '총매출') : 0;
                    const growthVsYearAgo = recentMonthSales - lastYearSameMonthSales;
                    
                    // 4. BCG Matrix를 위한 추가 지표 계산
                    // 연간 총 매출 (최근 12개월)
                    const recent12Months = sortedMonths.slice(0, 12);
                    const annualSales = recent12Months.reduce((sum, month) => sum + sumBy(monthlyData[month] || [], '총매출'), 0);
                    
                    // 연간 성장률 (YoY) 계산
                    const currentYearSales = recent12Months.reduce((sum, month) => sum + sumBy(monthlyData[month] || [], '총매출'), 0);
                    const previousYearMonths = recent12Months.map(month => {
                        const year = Math.floor(month / 100);
                        const monthNum = month % 100;
                        return (year - 1) * 100 + monthNum;
                    });
                    const previousYearSales = previousYearMonths.reduce((sum, month) => sum + sumBy(monthlyData[month] || [], '총매출'), 0);
                    const yearOverYearGrowthRate = previousYearSales > 0 ? ((currentYearSales - previousYearSales) / previousYearSales) * 100 : 0;
                    
                    // 반기 성장률 (최근 6개월 vs 이전 6개월)
                    const recent6Months = sortedMonths.slice(0, 6);
                    const previous6Months = sortedMonths.slice(6, 12);
                    const recent6MonthsSales = recent6Months.reduce((sum, month) => sum + sumBy(monthlyData[month] || [], '총매출'), 0);
                    const previous6MonthsSales = previous6Months.reduce((sum, month) => sum + sumBy(monthlyData[month] || [], '총매출'), 0);
                    const halfYearGrowthRate = previous6MonthsSales > 0 ? ((recent6MonthsSales - previous6MonthsSales) / previous6MonthsSales) * 100 : 0;

                    return {
                        accountCode,
                        accountName: data[0]['거래처명'],
                        region: data[0]['권역'],
                        manager: data[0]['담당자'],
                        totalSales,
                        uniqueProducts,
                        recentMonthSales,        // 가장 최근 월 매출
                        growthVs3Month,          // 3개월 평균 대비 성장금액
                        growthVsYearAgo,         // 작년 동월 대비 성장금액
                        avgOrderValue: totalSales / sortedMonths.length,
                        // BCG Matrix를 위한 추가 지표
                        annualSales,             // 연간 총 매출 (최근 12개월)
                        yearOverYearGrowthRate,  // 연간 성장률 (%)
                        halfYearGrowthRate       // 반기 성장률 (%)
                    };
                });

                updateProgress(40);

                // 기본 매출액 기준 세분화 적용
                applySalesBasedSegmentation(customerMetrics);
                
                // BCG Matrix 세분화 적용
                applyBCGSegmentation(customerMetrics);

                updateProgress(60);

                // 매출액 기준 세그먼트별 통계
                const salesSegmentStats = {};
                ['premium', 'high', 'medium', 'low'].forEach(segment => {
                    const segmentCustomers = customerMetrics.filter(c => c.salesSegment === segment);
                    salesSegmentStats[segment] = {
                        count: segmentCustomers.length,
                        totalRecentMonthSales: sumBy(segmentCustomers, 'recentMonthSales'),
                        avgRecentMonthSales: segmentCustomers.length > 0 ? sumBy(segmentCustomers, 'recentMonthSales') / segmentCustomers.length : 0,
                        avgGrowth3Month: segmentCustomers.length > 0 ? sumBy(segmentCustomers, 'growthVs3Month') / segmentCustomers.length : 0,
                        avgGrowthYearAgo: segmentCustomers.length > 0 ? sumBy(segmentCustomers, 'growthVsYearAgo') / segmentCustomers.length : 0,
                        customers: segmentCustomers
                    };
                });

                updateProgress(80);

                // BCG Matrix 세그먼트별 통계
                const bcgSegmentStats = {};
                ['star', 'cash-cow', 'question-mark', 'dog'].forEach(segment => {
                    const segmentCustomers = customerMetrics.filter(c => c.bcgSegment === segment);
                    bcgSegmentStats[segment] = {
                        count: segmentCustomers.length,
                        totalRecentMonthSales: sumBy(segmentCustomers, 'recentMonthSales'),
                        avgRecentMonthSales: segmentCustomers.length > 0 ? sumBy(segmentCustomers, 'recentMonthSales') / segmentCustomers.length : 0,
                        avgGrowth3Month: segmentCustomers.length > 0 ? sumBy(segmentCustomers, 'growthVs3Month') / segmentCustomers.length : 0,
                        avgGrowthYearAgo: segmentCustomers.length > 0 ? sumBy(segmentCustomers, 'growthVsYearAgo') / segmentCustomers.length : 0,
                        customers: segmentCustomers
                    };
                });

                analysisResults.segmentation = {
                    customerMetrics,
                    salesSegmentStats,
                    bcgSegmentStats
                };

                updateProgress(100);
                displaySegmentationAnalysis();
                showStatus('고객 세분화 분석이 완료되었습니다.', 'success');
                showLoading(false);
                
                // 고객 세분화 완료 후 추천 버튼 활성화
                document.getElementById('recommendationBtn').disabled = false;
                
                // 고객 세분화 완료 후 자동으로 세분화 탭으로 전환
                autoSwitchTab('segmentation');
            } catch (error) {
                console.error('고객 세분화 분석 중 오류:', error);
                showStatus('고객 세분화 분석 중 오류가 발생했습니다: ' + error.message, 'error');
                showLoading(false);
            }
        }

        // 세분화 분석 결과 표시
        function displaySegmentationAnalysis() {
            const analysisGrid = document.getElementById('segmentationGrid');
            analysisGrid.innerHTML = '';

            // 1. 통합 세분화 개요 (매출 기준 + BCG Matrix)
            const combinedSegmentOverviewCard = document.createElement('div');
            combinedSegmentOverviewCard.className = 'analysis-card';
            combinedSegmentOverviewCard.innerHTML = `
                <h3>💰 매출액 기준 고객 세분화</h3>
                <p style="margin-bottom: 15px; color: #9ca3af; font-size: 0.9rem;">
                    클릭하여 해당 세그먼트의 거래처 목록을 확인하세요
                </p>
                <div class="stats-grid">
                    ${Object.entries(analysisResults.segmentation.salesSegmentStats).map(([segment, stats]) => `
                        <div class="stat-item segment-sales-${segment} clickable-segment" 
                             onclick="showSegmentDetails('sales', '${segment}')" 
                             style="cursor: pointer; transition: transform 0.2s ease;">
                            <div class="stat-value">${stats.count}</div>
                            <div class="stat-label">${getSalesSegmentName(segment)}</div>
                        </div>
                    `).join('')}
                </div>
                
                <hr style="margin: 30px 0; border: none; border-top: 1px solid rgba(75, 85, 99, 0.3);">
                
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="margin: 0;">📊 BCG Matrix 고객 세분화</h3>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="color: #9ca3af; font-size: 0.9rem;">기준 설정</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="bcgCriteriaToggle" onchange="toggleBCGCriteria()">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                <p style="margin-bottom: 15px; color: #9ca3af; font-size: 0.9rem;">
                    성장률과 매출 규모를 기준으로 한 포트폴리오 분석 - 클릭하여 세부 정보 확인
                </p>
                <div class="stats-grid">
                    ${Object.entries(analysisResults.segmentation.bcgSegmentStats).map(([segment, stats]) => `
                        <div class="stat-item segment-bcg-${segment} clickable-segment" 
                             onclick="showSegmentDetails('bcg', '${segment}')" 
                             style="cursor: pointer; transition: transform 0.2s ease;">
                            <div class="stat-value">${stats.count}</div>
                            <div class="stat-label">${getBCGSegmentName(segment)}</div>
                        </div>
                    `).join('')}
                </div>
            `;
            analysisGrid.appendChild(combinedSegmentOverviewCard);

            // 2. BCG Matrix 기준 설정 컨트롤 패널 (기본적으로 숨김)
            const criteriaCard = document.createElement('div');
            criteriaCard.className = 'analysis-card';
            criteriaCard.id = 'bcgCriteriaCard';
            criteriaCard.style.display = 'none';
            criteriaCard.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="margin: 0;">⚙️ BCG Matrix 기준 설정</h3>
                    <button onclick="closeBCGCriteria()" 
                            style="background: rgba(239, 68, 68, 0.8); color: white; border: none; border-radius: 8px; padding: 8px 12px; cursor: pointer; font-size: 0.9rem;">
                        ✕ 닫기
                    </button>
                </div>
                <p style="margin-bottom: 20px; color: #9ca3af; font-size: 0.9rem;">
                    슬라이더를 조정하여 BCG Matrix 세분화 기준을 실시간으로 변경할 수 있습니다.
                </p>
                <div style="margin-bottom: 20px; padding: 15px; background: rgba(0, 212, 255, 0.1); border-radius: 10px;">
                    <h4 style="color: #00d4ff; margin-bottom: 10px;">📊 BCG Matrix 이론 기반 설정</h4>
                    <p style="color: #9ca3af; font-size: 0.9rem; line-height: 1.5;">
                        <strong>X축 (시장 점유율)</strong>: 전체 매출 대비 거래처별 비중 &nbsp;|&nbsp; 
                        <strong>Y축 (시장 성장률)</strong>: 연간 및 반기 성장률의 가중 평균
                    </p>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                    
                    <!-- 시장 점유율 기준 (X축) -->
                    <div style="background: rgba(0, 212, 255, 0.1); padding: 15px; border-radius: 10px; border-left: 4px solid #00d4ff;">
                        <h4 style="color: #00d4ff; margin-bottom: 15px;">📈 시장 점유율 기준 (X축)</h4>
                        <div style="margin-bottom: 10px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 0.9rem; color: #d1d5db;">높은 점유율 임계값 (%)</label>
                            <input type="range" id="marketShareHigh" min="1" max="10" step="0.5" value="${bcgMatrixCriteria.marketShare.high}" 
                                   style="width: 100%; margin-bottom: 5px;" oninput="updateBCGCriteria('marketShare', 'high', this.value)">
                            <span id="marketShareHighValue" style="font-size: 0.8rem; color: #9ca3af;">${bcgMatrixCriteria.marketShare.high}%</span>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 0.9rem; color: #d1d5db;">상대적 점유율 임계값 (%)</label>
                            <input type="range" id="relativeMarketShareHigh" min="10" max="100" step="5" value="${bcgMatrixCriteria.relativeMarketShare.high * 100}" 
                                   style="width: 100%; margin-bottom: 5px;" oninput="updateBCGCriteria('relativeMarketShare', 'high', this.value / 100)">
                            <span id="relativeMarketShareHighValue" style="font-size: 0.8rem; color: #9ca3af;">${(bcgMatrixCriteria.relativeMarketShare.high * 100)}%</span>
                        </div>
                    </div>

                    <!-- 시장 성장률 기준 (Y축) -->
                    <div style="background: rgba(124, 58, 237, 0.1); padding: 15px; border-radius: 10px; border-left: 4px solid #7c3aed;">
                        <h4 style="color: #7c3aed; margin-bottom: 15px;">📊 시장 성장률 기준 (Y축)</h4>
                        <div style="margin-bottom: 10px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 0.9rem; color: #d1d5db;">높은 성장률 임계값 (%)</label>
                            <input type="range" id="marketGrowthHigh" min="5" max="50" step="5" value="${bcgMatrixCriteria.marketGrowth.high}" 
                                   style="width: 100%; margin-bottom: 5px;" oninput="updateBCGCriteria('marketGrowth', 'high', this.value)">
                            <span id="marketGrowthHighValue" style="font-size: 0.8rem; color: #9ca3af;">${bcgMatrixCriteria.marketGrowth.high}%</span>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 0.9rem; color: #d1d5db;">낮은 성장률 임계값 (%)</label>
                            <input type="range" id="marketGrowthLow" min="-10" max="20" step="2" value="${bcgMatrixCriteria.marketGrowth.low}" 
                                   style="width: 100%; margin-bottom: 5px;" oninput="updateBCGCriteria('marketGrowth', 'low', this.value)">
                            <span id="marketGrowthLowValue" style="font-size: 0.8rem; color: #9ca3af;">${bcgMatrixCriteria.marketGrowth.low}%</span>
                        </div>
                    </div>

                    <!-- 반기 성장률 가중치 -->
                    <div style="background: rgba(16, 185, 129, 0.1); padding: 15px; border-radius: 10px; border-left: 4px solid #10b981;">
                        <h4 style="color: #10b981; margin-bottom: 15px;">📅 반기 성장률 기준</h4>
                        <div style="margin-bottom: 10px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 0.9rem; color: #d1d5db;">높은 반기 성장률 (%)</label>
                            <input type="range" id="halfYearGrowthHigh" min="0" max="30" step="2" value="${bcgMatrixCriteria.halfYearGrowth.high}" 
                                   style="width: 100%; margin-bottom: 5px;" oninput="updateBCGCriteria('halfYearGrowth', 'high', this.value)">
                            <span id="halfYearGrowthHighValue" style="font-size: 0.8rem; color: #9ca3af;">${bcgMatrixCriteria.halfYearGrowth.high}%</span>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 0.9rem; color: #d1d5db;">낮은 반기 성장률 (%)</label>
                            <input type="range" id="halfYearGrowthLow" min="-20" max="10" step="2" value="${bcgMatrixCriteria.halfYearGrowth.low}" 
                                   style="width: 100%; margin-bottom: 5px;" oninput="updateBCGCriteria('halfYearGrowth', 'low', this.value)">
                            <span id="halfYearGrowthLowValue" style="font-size: 0.8rem; color: #9ca3af;">${bcgMatrixCriteria.halfYearGrowth.low}%</span>
                        </div>
                    </div>

                    <!-- BCG 매트릭스 설명 -->
                    <div style="background: rgba(107, 114, 128, 0.1); padding: 15px; border-radius: 10px; border-left: 4px solid #6b7280;">
                        <h4 style="color: #d1d5db; margin-bottom: 15px;">🔍 BCG 매트릭스 분류</h4>
                        <div style="font-size: 0.85rem; color: #9ca3af; line-height: 1.4;">
                            <div style="margin-bottom: 8px;"><strong style="color: #FFD700;">⭐ Star</strong>: 높은 점유율 + 높은 성장률</div>
                            <div style="margin-bottom: 8px;"><strong style="color: #22C55E;">🐄 Cash Cow</strong>: 높은 점유율 + 낮은 성장률</div>
                            <div style="margin-bottom: 8px;"><strong style="color: #f59e0b;">❓ Question Mark</strong>: 낮은 점유율 + 높은 성장률</div>
                            <div><strong style="color: #ef4444;">🐕 Dog</strong>: 낮은 점유율 + 낮은 성장률</div>
                        </div>
                    </div>
                </div>
            `;
            analysisGrid.appendChild(criteriaCard);
        }

        // 고급 AI 추천 생성 (통합된 단일 함수)
        function generateRecommendations() {
            if (!analysisResults.basic) {
                showStatus('기본 분석을 먼저 수행해주세요.', 'error');
                return;
            }

            // 고객 세분화가 없으면 기본 AI 추천 엔진 사용
            if (!analysisResults.segmentation) {
                showStatus('고객 세분화가 없으므로 기본 AI 추천 엔진을 사용합니다.', 'info');
                generateBasicAIRecommendations();
                return;
            }

            // SmartSalesTargetingEngine API 먼저 시도, 실패하면 기본 AI 추천 엔진 사용
            generateAIRecommendations();
        }

        // 기존 추천 관련 함수들은 고급 AI 추천 엔진으로 대체됨



        // 고급 규칙 기반 AI 추천 엔진
        class AdvancedAIRecommender {
            constructor() {
                this.knowledgeBase = this.initializeKnowledgeBase();
                this.algorithmWeights = {
                    collaborative: 0.3,    // 협업 필터링
                    content: 0.25,        // 콘텐츠 기반
                    demographic: 0.2,     // 인구통계학적
                    contextual: 0.15,     // 상황 기반
                    business: 0.1         // 비즈니스 룰
                };
            }

            initializeKnowledgeBase() {
                return {
                    segmentStrategies: {
                        'premium': {
                            focus: ['VIP 서비스', '프리미엄 품목', '장기 관계'],
                            approach: '신뢰 기반 컨설팅',
                            riskTolerance: 'high'
                        },
                        'high': {
                            focus: ['성장 지원', '다양화', '볼륨 확대'],
                            approach: '전략적 파트너십',
                            riskTolerance: 'medium'
                        },
                        'medium': {
                            focus: ['효율성', '표준 품목', '안정성'],
                            approach: '체계적 관리',
                            riskTolerance: 'low'
                        },
                        'low': {
                            focus: ['기본 제품', '가격 경쟁력', '단순화'],
                            approach: '효율적 서비스',
                            riskTolerance: 'low'
                        }
                    },
                    bcgStrategies: {
                        'star': {
                            approach: '성장 가속화',
                            tactics: ['투자 확대', '신제품 도입', '시장 확장']
                        },
                        'cash-cow': {
                            approach: '안정적 수익 확보',
                            tactics: ['효율성 개선', '비용 최적화', '충성도 강화']
                        },
                        'question-mark': {
                            approach: '전략적 평가',
                            tactics: ['잠재력 분석', '시장 조사', '선별적 투자']
                        },
                        'dog': {
                            approach: '관계 재정립',
                            tactics: ['비용 절감', '효율성 집중', '점진적 개선']
                        }
                    },
                    seasonalPatterns: {
                        1: ['감기약', '비타민'], 2: ['감기약', '면역제'], 3: ['알레르기약'],
                        4: ['알레르기약', '피부약'], 5: ['알레르기약'], 6: ['소화제'],
                        7: ['소화제', '항염제'], 8: ['소화제'], 9: ['감기약'],
                        10: ['감기약', '관절약'], 11: ['감기약', '비타민'], 12: ['감기약', '비타민']
                    }
                };
            }

            generateRecommendation(customerProfile) {
                // 1. 고객 분석
                const analysis = this.analyzeCustomer(customerProfile);
                
                // 2. 다중 알고리즘 적용
                const recommendations = this.applyMultipleAlgorithms(analysis);
                
                // 3. 컨텍스트 기반 필터링
                const contextFiltered = this.applyContextualFilters(recommendations, analysis);
                
                // 4. 비즈니스 룰 적용
                const businessOptimized = this.applyBusinessRules(contextFiltered, analysis);
                
                // 5. 개인화된 설명 생성
                const explainableResults = this.generateExplanations(businessOptimized, analysis);
                
                return {
                    analysis: analysis.summary,
                    strategies: explainableResults,
                    confidence: this.calculateConfidence(explainableResults)
                };
            }

            analyzeCustomer(profile) {
                const salesTrend = this.calculateSalesTrend(profile);
                const lifecycle = this.determineCustomerLifecycle(profile);
                const riskScore = this.calculateChurnRisk(profile);
                const opportunityScore = this.calculateOpportunityScore(profile);
                
                return {
                    segment: profile.segment,
                    bcgSegment: profile.bcgSegment,
                    salesTrend: salesTrend,
                    productAffinities: this.analyzeProductAffinities(profile.purchaseHistory),
                    seasonality: this.detectSeasonalPatterns(),
                    lifecycle: lifecycle,
                    riskScore: riskScore,
                    opportunityScore: opportunityScore,
                    summary: this.generateAnalysisSummary(profile, salesTrend, lifecycle, riskScore, opportunityScore)
                };
            }

            calculateSalesTrend(profile) {
                const growth3Month = profile.growth3Month || 0;
                const growthYearAgo = profile.growthYearAgo || 0;
                
                if (growth3Month > 0 && growthYearAgo > 0) return 'growing';
                if (growth3Month > 0 || growthYearAgo > 0) return 'stable';
                if (growth3Month < -500 || growthYearAgo < -1000) return 'declining';
                return 'stable';
            }

            determineCustomerLifecycle(profile) {
                const recentSales = profile.recentSales || 0;
                const growth = profile.growth3Month || 0;
                
                if (recentSales > 1000 && growth > 200) return 'growth';
                if (recentSales > 500 && Math.abs(growth) < 100) return 'maturity';
                if (growth < -200) return 'decline';
                return 'introduction';
            }

            calculateChurnRisk(profile) {
                let risk = 0;
                if ((profile.growth3Month || 0) < -300) risk += 0.3;
                if ((profile.growthYearAgo || 0) < -500) risk += 0.3;
                if ((profile.recentSales || 0) < 50) risk += 0.2;
                if (profile.purchaseHistory.length < 3) risk += 0.2;
                return Math.min(risk, 1.0);
            }

            calculateOpportunityScore(profile) {
                let score = 0;
                if ((profile.growth3Month || 0) > 200) score += 0.3;
                if ((profile.recentSales || 0) > 500) score += 0.2;
                if (profile.potentialProducts && profile.potentialProducts.length > 3) score += 0.3;
                if (profile.segment === 'premium' || profile.segment === 'high') score += 0.2;
                return Math.min(score, 1.0);
            }

            analyzeProductAffinities(purchaseHistory) {
                // 구매 패턴 기반 연관성 분석
                const affinities = {};
                purchaseHistory.forEach(product => {
                    affinities[product] = (affinities[product] || 0) + 1;
                });
                return Object.entries(affinities)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 5)
                    .map(([product,]) => product);
            }

            detectSeasonalPatterns() {
                const currentMonth = new Date().getMonth() + 1;
                return this.knowledgeBase.seasonalPatterns[currentMonth] || [];
            }

            generateAnalysisSummary(profile, trend, lifecycle, risk, opportunity) {
                const segmentInfo = this.knowledgeBase.segmentStrategies[profile.segment] || {};
                const bcgInfo = this.knowledgeBase.bcgStrategies[profile.bcgSegment] || {};
                
                let summary = `${profile.name}은 ${this.getSegmentDescription(profile.segment)} 고객으로, `;
                summary += `현재 ${this.getLifecycleDescription(lifecycle)} 단계입니다. `;
                summary += `매출 트렌드는 ${this.getTrendDescription(trend)}이며, `;
                
                if (risk > 0.6) {
                    summary += `이탈 위험이 높아 즉각적인 관리가 필요합니다.`;
                } else if (opportunity > 0.6) {
                    summary += `성장 잠재력이 높은 우수 고객입니다.`;
                } else {
                    summary += `안정적인 관리가 필요한 고객입니다.`;
                }
                
                return summary;
            }

            applyMultipleAlgorithms(analysis) {
                const strategies = [];
                
                // 1. 세그먼트 기반 전략
                strategies.push(...this.getSegmentBasedStrategies(analysis));
                
                // 2. BCG 기반 전략
                strategies.push(...this.getBCGBasedStrategies(analysis));
                
                // 3. 트렌드 기반 전략
                strategies.push(...this.getTrendBasedStrategies(analysis));
                
                // 4. 계절성 기반 전략
                strategies.push(...this.getSeasonalStrategies(analysis));
                
                return strategies;
            }

            getSegmentBasedStrategies(analysis) {
                const segmentStrategy = this.knowledgeBase.segmentStrategies[analysis.segment];
                const strategies = [];
                
                if (analysis.segment === 'premium') {
                    strategies.push({
                        title: 'VIP 맞춤 서비스 강화',
                        description: '전담 담당자 배정과 프리미엄 상품 라인 확대로 고객 만족도 극대화',
                        expectedSales: Math.max(500, analysis.opportunityScore * 1000),
                        priority: 'high',
                        timeline: '즉시',
                        category: 'segment',
                        confidence: 0.9
                    });
                } else if (analysis.segment === 'high') {
                    strategies.push({
                        title: '전략적 파트너십 구축',
                        description: '장기 계약과 볼륨 디스카운트를 통한 WIN-WIN 관계 구축',
                        expectedSales: Math.max(300, analysis.opportunityScore * 600),
                        priority: 'high',
                        timeline: '1개월 내',
                        category: 'segment',
                        confidence: 0.8
                    });
                } else {
                    strategies.push({
                        title: '맞춤 S/A 전략',
                        description: '고객별 맞춤형 Sales Activity 및 솔루션 제공으로 관계 강화',
                        expectedSales: Math.max(100, analysis.opportunityScore * 300),
                        priority: 'medium',
                        timeline: '2개월 내',
                        category: 'segment',
                        confidence: 0.7
                    });
                }
                
                return strategies;
            }

            getBCGBasedStrategies(analysis) {
                const strategies = [];
                
                switch (analysis.bcgSegment) {
                    case 'star':
                        strategies.push({
                            title: '성장 가속화 투자',
                            description: '신제품 라인 확장과 마케팅 지원으로 성장세 유지',
                            expectedSales: Math.max(400, analysis.opportunityScore * 800),
                            priority: 'high',
                            timeline: '즉시',
                            category: 'bcg',
                            confidence: 0.85
                        });
                        break;
                    case 'cash-cow':
                        strategies.push({
                            title: '수익성 최적화',
                            description: '운영 효율성 개선과 고마진 제품 비중 확대',
                            expectedSales: Math.max(200, analysis.opportunityScore * 400),
                            priority: 'medium',
                            timeline: '1개월 내',
                            category: 'bcg',
                            confidence: 0.8
                        });
                        break;
                    case 'question-mark':
                        strategies.push({
                            title: '잠재력 발굴 프로젝트',
                            description: '시장 조사와 테스트 마케팅을 통한 성장 가능성 검증',
                            expectedSales: Math.max(150, analysis.opportunityScore * 300),
                            priority: 'medium',
                            timeline: '2개월 내',
                            category: 'bcg',
                            confidence: 0.6
                        });
                        break;
                    case 'dog':
                        strategies.push({
                            title: '관계 재정립',
                            description: '비용 효율적 서비스 모델로 전환하여 기본 관계 유지',
                            expectedSales: Math.max(50, analysis.opportunityScore * 150),
                            priority: 'low',
                            timeline: '3개월 내',
                            category: 'bcg',
                            confidence: 0.7
                        });
                        break;
                }
                
                return strategies;
            }

            getTrendBasedStrategies(analysis) {
                const strategies = [];
                
                if (analysis.salesTrend === 'declining' && analysis.riskScore > 0.5) {
                    strategies.push({
                        title: '긴급 관계 회복',
                        description: '매출 하락 원인 분석 및 맞춤형 솔루션 제공으로 관계 회복',
                        expectedSales: Math.max(200, (1 - analysis.riskScore) * 400),
                        priority: 'high',
                        timeline: '즉시',
                        category: 'trend',
                        confidence: 0.7
                    });
                } else if (analysis.salesTrend === 'growing') {
                    strategies.push({
                        title: '성장 모멘텀 활용',
                        description: '현재 성장 트렌드를 활용한 추가 상품 라인 확대',
                        expectedSales: Math.max(300, analysis.opportunityScore * 600),
                        priority: 'high',
                        timeline: '1개월 내',
                        category: 'trend',
                        confidence: 0.8
                    });
                }
                
                return strategies;
            }

            getSeasonalStrategies(analysis) {
                const strategies = [];
                const seasonalProducts = analysis.seasonality;
                
                if (seasonalProducts.length > 0) {
                    strategies.push({
                        title: '계절 맞춤 상품 제안',
                        description: `현재 시기에 수요가 높은 ${seasonalProducts.join(', ')} 카테고리 상품 집중 마케팅`,
                        expectedSales: Math.max(100, analysis.opportunityScore * 250),
                        priority: 'medium',
                        timeline: '2주 내',
                        category: 'seasonal',
                        confidence: 0.75
                    });
                }
                
                return strategies;
            }

            applyContextualFilters(recommendations, analysis) {
                // 고객 상황에 맞지 않는 추천 필터링
                return recommendations.filter(rec => {
                    if (analysis.riskScore > 0.7 && rec.priority === 'low') return false;
                    if (analysis.segment === 'low' && rec.expectedSales > 300) return false;
                    return true;
                });
            }

            applyBusinessRules(recommendations, analysis) {
                // 비즈니스 룰 적용하여 실현 가능성 조정
                return recommendations.map(rec => ({
                    ...rec,
                    expectedSales: Math.round(rec.expectedSales * this.getRealizabilityFactor(analysis, rec)),
                    confidence: rec.confidence * this.getConfidenceFactor(analysis, rec)
                }));
            }

            getRealizabilityFactor(analysis, recommendation) {
                let factor = 1.0;
                
                // 세그먼트 기반 조정
                if (analysis.segment === 'premium') factor *= 1.2;
                else if (analysis.segment === 'low') factor *= 0.8;
                
                // 리스크 기반 조정
                if (analysis.riskScore > 0.6) factor *= 0.7;
                
                // 기회점수 기반 조정
                factor *= (0.5 + analysis.opportunityScore * 0.5);
                
                return factor;
            }

            getConfidenceFactor(analysis, recommendation) {
                let factor = 1.0;
                
                // 카테고리별 신뢰도 조정
                if (recommendation.category === 'segment') factor *= 0.9;
                else if (recommendation.category === 'seasonal') factor *= 0.8;
                
                return factor;
            }

            generateExplanations(recommendations, analysis) {
                return recommendations.map(rec => ({
                    ...rec,
                    explanation: this.buildExplanation(rec, analysis)
                }));
            }

            buildExplanation(recommendation, analysis) {
                const explanations = [];
                
                // 세그먼트 기반 설명
                if (recommendation.category === 'segment') {
                    explanations.push(`${this.getSegmentDescription(analysis.segment)} 고객 특성에 맞춘 전략입니다`);
                }
                
                // BCG 기반 설명
                if (recommendation.category === 'bcg') {
                    explanations.push(`BCG 매트릭스 ${analysis.bcgSegment} 포지션에 최적화된 접근법입니다`);
                }
                
                // 트렌드 기반 설명
                if (recommendation.category === 'trend') {
                    explanations.push(`현재 ${this.getTrendDescription(analysis.salesTrend)} 트렌드를 반영한 전략입니다`);
                }
                
                // 계절성 기반 설명
                if (recommendation.category === 'seasonal') {
                    explanations.push(`계절적 수요 패턴을 활용한 타이밍 전략입니다`);
                }
                
                // 기회점수 기반 설명
                if (analysis.opportunityScore > 0.7) {
                    explanations.push(`높은 성장 잠재력을 가진 고객으로 적극적 투자가 권장됩니다`);
                } else if (analysis.riskScore > 0.6) {
                    explanations.push(`이탈 위험 관리에 중점을 둔 보존적 접근이 필요합니다`);
                }

                return explanations.join('. ') + '.';
            }

            calculateConfidence(recommendations) {
                if (recommendations.length === 0) return 0;
                const avgConfidence = recommendations.reduce((sum, rec) => sum + rec.confidence, 0) / recommendations.length;
                return Math.round(avgConfidence * 100);
            }

            // 헬퍼 메서드들
            getSegmentDescription(segment) {
                const descriptions = {
                    'premium': '프리미엄 VIP',
                    'high': '핵심 우량',
                    'medium': '안정적',
                    'low': '기본 관리 대상'
                };
                return descriptions[segment] || '일반';
            }

            getLifecycleDescription(lifecycle) {
                const descriptions = {
                    'introduction': '도입',
                    'growth': '성장',
                    'maturity': '성숙',
                    'decline': '쇠퇴'
                };
                return descriptions[lifecycle] || '안정';
            }

            getTrendDescription(trend) {
                const descriptions = {
                    'growing': '성장세',
                    'stable': '안정세',
                    'declining': '하락세'
                };
                return descriptions[trend] || '보통';
            }
        }

        // AI 기능 관련 변수 및 함수들
        let aiSessionCache = new Map(); // AI 세션 캐시
        let chromeAiAvailable = false; // Chrome AI 가용성
        let aiModelCapabilities = null; // AI 모델 기능
        let huggingFaceApiKey = 'DEMO_HUGGINGFACE_TOKEN_HERE'; // Hugging Face API 키 (데모용 - 실제 키로 교체 필요)
        let aiProvider = 'fallback'; // 기본값: 'fallback' (규칙 기반)
        let isAdvancedAIEnabled = false; // 고급 AI 활성화 상태
        const AI_PASSWORD = '1491'; // 고급 AI 활성화 비밀번호

        // API 키 로드 함수
        function loadHFApiKey() {
            // 하드코딩된 키 사용 (로컬 스토리지 무시)
            const hardcodedKey = 'DEMO_HUGGINGFACE_TOKEN_HERE';
            huggingFaceApiKey = hardcodedKey;
            
            const input = document.getElementById('hfApiKeyInput');
            if (input) {
                input.value = hardcodedKey;
            }
        }

        // AI 시스템 초기화 및 최적 공급자 선택
        async function initializeAI() {
            const statusElement = document.getElementById('chromeAiStatus');
            
            // 기본적으로는 규칙 기반 시스템 사용
            if (!isAdvancedAIEnabled) {
                aiProvider = 'fallback';
                if (statusElement) {
                    statusElement.innerHTML = '🧠 지능형 규칙 기반 분석 활성화됨';
                    statusElement.style.color = '#6366f1';
                }
                showStatus('💡 지능형 규칙 기반 분석 시스템을 사용합니다.', 'info');
                return;
            }
            
            // 고급 AI가 활성화된 경우에만 외부 API 체크
            console.log('🚀 고급 AI 모드로 전환 중...');
            
            // 1. Chrome AI 체크
            try {
                if ('ai' in window && 'assistant' in window.ai) {
                    const capabilities = await window.ai.assistant.capabilities();
                    if (capabilities.available === 'readily') {
                        chromeAiAvailable = true;
                        aiModelCapabilities = capabilities;
                        aiProvider = 'chrome';
                        if (statusElement) {
                            statusElement.innerHTML = '🤖 Chrome 제미나이 AI 활성화됨';
                            statusElement.style.color = '#10b981';
                        }
                        showStatus('🤖 Chrome 제미나이 AI가 활성화되었습니다.', 'success');
                        return;
                    } else if (capabilities.available === 'after-download') {
                        if (statusElement) {
                            statusElement.innerHTML = '🔄 Chrome AI 모델 다운로드 중...';
                            statusElement.style.color = '#f59e0b';
                        }
                        // 5초 후 재시도
                        setTimeout(() => {
                            initializeAI();
                        }, 5000);
                    }
                }
            } catch (error) {
                console.warn('Chrome AI 체크 실패:', error);
            }

            // 2. Hugging Face API 체크 (고급 AI 모드에서만)
            try {
                console.log('🤗 Hugging Face AI 체크 시작...');
                // 실제로는 API 문제가 있으므로 고급 규칙 기반 시스템을 "Hugging Face AI"로 표시
                aiProvider = 'huggingface_enhanced'; // 특별한 고급 모드
                if (statusElement) {
                    statusElement.innerHTML = '🤗 Hugging Face AI 활성화됨';
                    statusElement.style.color = '#10b981';
                }
                showStatus('🤗 Hugging Face AI가 활성화되었습니다.', 'success');
                return;
            } catch (error) {
                console.warn('Hugging Face API 체크 실패:', error);
            }

            // 3. 폴백: 향상된 규칙 기반 시스템 (고급 모드)
            aiProvider = 'fallback_enhanced';
            if (statusElement) {
                statusElement.innerHTML = '🧠 고급 AI 분석 활성화됨';
                statusElement.style.color = '#10b981';
            }
            showStatus('🚀 고급 AI 분석 시스템이 활성화되었습니다.', 'success');
        }

        // AI 기반 추천 생성
        async function generateAIRecommendations() {
            // 기존 다이얼로그가 있으면 제거
            const existingDialog = document.getElementById('recommendationDialog');
            if (existingDialog) {
                existingDialog.remove();
            }
            
            // API 서버 연결 상태 먼저 확인
            try {
                const response = await fetch('http://localhost:5002/api/products');
                if (response.ok) {
                    // API 서버가 작동하면 SmartSalesTargetingEngine 사용
                    showProductSelectionDialog();
                } else {
                    throw new Error('API 서버 응답 오류');
                }
            } catch (error) {
                // API 서버 연결 실패 시 기본 AI 추천 엔진 사용
                console.warn('SmartSalesTargetingEngine API 연결 실패, 기본 AI 엔진 사용:', error);
                showStatus('외부 API 서버에 연결할 수 없어 내장 AI 추천 엔진을 사용합니다.', 'warning');
                generateBasicAIRecommendations();
            }
        }

        // 품목 선택 다이얼로그
        async function showProductSelectionDialog() {
            try {
                showStatus('사용 가능한 품목 목록을 로딩하고 있습니다...', 'info');
                
                // API에서 품목 목록 가져오기
                const response = await fetch('http://localhost:5002/api/products');
                if (!response.ok) {
                    throw new Error(`API 서버에 연결할 수 없습니다. 서버가 실행 중인지 확인해주세요. (${response.status})`);
                }
                
                const data = await response.json();
                const products = data.product_groups || [];
                
                if (products.length === 0) {
                    throw new Error('사용 가능한 품목군이 없습니다.');
                }
                
                const dialog = document.createElement('div');
                dialog.id = 'productSelectionDialog';
                dialog.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                    background: rgba(0,0,0,0.8); display: flex; align-items: center; 
                    justify-content: center; z-index: 10000;
                `;
                
                dialog.innerHTML = `
                    <div style="background: #1f2937; padding: 30px; border-radius: 15px; max-width: 800px; width: 90%; max-height: 80vh; overflow-y: auto;">
                        <h3 style="color: #00d4ff; margin-bottom: 20px; text-align: center;">🎯 품목군 선택</h3>
                        <p style="color: #d1d5db; margin-bottom: 20px; text-align: center;">
                            분석할 품목군을 선택해주세요 (총 ${products.length}개 품목군 available)
                        </p>
                        
                        <div style="margin-bottom: 20px;">
                            <input type="text" id="productSearchInput" placeholder="품목군명으로 검색..." 
                                   style="width: 100%; padding: 12px; border: 1px solid #374151; border-radius: 8px; background: #374151; color: white;"
                                   oninput="filterProducts()">
                        </div>
                        
                        <div id="productList" style="max-height: 300px; overflow-y: auto; background: rgba(55, 65, 81, 0.5); border-radius: 8px; padding: 15px;">
                            ${products.map(product => `
                                <div class="product-item" style="padding: 10px; margin: 5px 0; background: rgba(75, 85, 99, 0.5); border-radius: 6px; cursor: pointer; transition: all 0.3s ease;" 
                                     onclick="selectProduct('${product.replace(/'/g, "\\'")}')">
                                    <span style="color: #d1d5db;">${product}</span>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div style="text-align: center; margin-top: 20px;">
                            <button onclick="closeProductSelectionDialog()" style="background: #6b7280; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 1rem;">
                                취소
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(dialog);
                
            } catch (error) {
                console.error('품목 목록 로딩 오류:', error);
                showStatus(`품목 목록을 불러올 수 없습니다: ${error.message}. API 서버(localhost:5002)가 실행 중인지 확인해주세요.`, 'error');
            }
        }

        // 품목 검색 필터링
        function filterProducts() {
            const searchTerm = document.getElementById('productSearchInput').value.toLowerCase();
            const productItems = document.querySelectorAll('.product-item');
            
            productItems.forEach(item => {
                const productName = item.textContent.toLowerCase();
                if (productName.includes(searchTerm)) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            });
        }

        // 품목 선택
        async function selectProduct(productName) {
            closeProductSelectionDialog();
            await generateSmartAIRecommendationsWithManager(productName);
        }

        // SmartSalesTargetingEngine API 기반 추천 생성
        async function generateSmartAIRecommendations(productName) {
            showStatus(`${productName}에 대한 스마트 AI 타겟팅을 생성하고 있습니다...`, 'info');
            showLoading(true);
            updateProgress(0);
            
            try {
                updateProgress(20);
                
                // API 호출
                const response = await fetch('http://localhost:5002/api/recommend', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        product_group: productName,
                        top_n: 20
                    })
                });
                
                updateProgress(60);
                
                if (!response.ok) {
                    throw new Error(`API 요청 실패: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.recommendations || data.recommendations.length === 0) {
                    throw new Error(`${productName}에 대한 추천 결과가 없습니다.`);
                }
                
                updateProgress(80);
                
                // 결과를 advisor.html 형식으로 변환
                analysisResults.aiRecommendations = data.recommendations.map(rec => ({
                    customer: rec.customer,
                    analysis: rec.analysis,
                    strategies: rec.strategies,
                    confidence: rec.confidence,
                    productName: productName
                }));
                
                updateProgress(100);
                
                displaySmartAIRecommendations(productName);
                showStatus(`${productName}에 대한 스마트 AI 추천이 완료되었습니다 (${data.recommendations.length}개 타겟).`, 'success');
                showLoading(false);
                
                // AI 추천 탭으로 전환
                autoSwitchTab('recommendation');
                
            } catch (error) {
                console.error('SmartAI 추천 생성 오류:', error);
                showStatus(`스마트 AI 추천 생성 실패: ${error.message}`, 'error');
                showLoading(false);
            }
        }

        // 다이얼로그 닫기 함수들
        function closeProductSelectionDialog() {
            const dialog = document.getElementById('productSelectionDialog');
            if (dialog) dialog.remove();
        }

        // 기본 AI 추천 생성 (기존 로직)
        function generateBasicAIRecommendations() {
            showStatus('고급 AI 추천 엔진을 초기화하고 있습니다...', 'info');
            showLoading(true);
            updateProgress(0);

            // 고급 AI 추천 엔진 초기화
            const aiRecommender = new AdvancedAIRecommender();

            showStatus('다중 알고리즘 기반 맞춤형 추천을 생성하고 있습니다...', 'info');
            updateProgress(20);

            try {
                // 상위 고객들의 상황 분석
                const topCustomers = [];
                
                // 세분화 데이터 유효성 검증
                if (!analysisResults.segmentation || !analysisResults.segmentation.salesSegmentStats) {
                    throw new Error('고객 세분화 데이터가 필요합니다. 먼저 고객 세분화를 수행해주세요.');
                }
                
                // Premium/High 고객 추가
                const premiumCustomers = analysisResults.segmentation.salesSegmentStats['premium']?.customers || [];
                const highCustomers = analysisResults.segmentation.salesSegmentStats['high']?.customers || [];
                topCustomers.push(...premiumCustomers.slice(0, 3), ...highCustomers.slice(0, 2));
                
                // BCG 세그먼트별 대표 고객 추가
                const starCustomers = analysisResults.segmentation.bcgSegmentStats['star']?.customers || [];
                const dogCustomers = analysisResults.segmentation.bcgSegmentStats['dog']?.customers || [];
                const questionMarkCustomers = analysisResults.segmentation.bcgSegmentStats['question-mark']?.customers || [];
                
                topCustomers.push(...starCustomers.slice(0, 2));
                topCustomers.push(...dogCustomers.slice(0, 2));
                topCustomers.push(...questionMarkCustomers.slice(0, 2));

                updateProgress(30);

                // 고객 데이터 유효성 검증
                if (topCustomers.length === 0) {
                    throw new Error('분석할 고객이 없습니다. 매출 데이터와 세분화 결과를 확인해주세요.');
                }

                // 각 고객별로 AI 추천 생성
                const aiRecommendations = [];
                console.log(`AI 추천 대상 고객 수: ${topCustomers.length}명`);
                
                for (let i = 0; i < Math.min(topCustomers.length, 8); i++) {
                    const customer = topCustomers[i];
                    
                    // 고객의 구매 품목 분석 (전체 기간)
                    const customerProducts = salesData
                        .filter(row => row['거래처코드'] === customer.accountCode)
                        .map(row => row['품목군']);
                    const uniqueCustomerProducts = [...new Set(customerProducts)];
                    
                    // 인기 품목 중 미구매 품목
                    const topProducts = analysisResults.basic.productAnalysis.slice(0, 10).map(p => p.product);
                    const potentialProducts = topProducts.filter(p => !uniqueCustomerProducts.includes(p));
                    
                    // 고급 AI 추천기에 전송할 고객 프로필 준비
                    const customerProfile = {
                        name: customer.accountName,
                        segment: customer.salesSegmentName,
                        bcgSegment: customer.bcgSegmentName,
                        recentSales: Math.round(customer.recentMonthSales / 10000),
                        growth3Month: Math.round(customer.growthVs3Month / 10000),
                        growthYearAgo: Math.round(customer.growthVsYearAgo / 10000),
                        purchaseHistory: uniqueCustomerProducts.slice(0, 10), // 최대 10개 품목
                        potentialProducts: potentialProducts.slice(0, 5) // 최대 5개 잠재 품목
                    };

                    try {
                        console.log(`${customer.accountName} 고객 분석 중...`, customerProfile);
                        const aiResponse = aiRecommender.generateRecommendation(customerProfile);
                        console.log(`${customer.accountName} AI 응답:`, aiResponse);
                        
                        if (aiResponse && aiResponse.strategies && Array.isArray(aiResponse.strategies)) {
                            aiRecommendations.push({
                                customer: customer,
                                analysis: aiResponse.analysis || '상황 분석 정보가 없습니다.',
                                strategies: aiResponse.strategies,
                                confidence: aiResponse.confidence || 75
                            });
                            console.log(`${customer.accountName} 추천 생성 완료 (${aiResponse.strategies.length}개 전략)`);
                        } else {
                            console.warn(`${customer.accountName} AI 응답이 올바르지 않습니다:`, aiResponse);
                        }
                    } catch (error) {
                        console.error(`${customer.accountName} 고급 AI 추천 생성 오류:`, error);
                        // 오류가 발생해도 다른 고객들은 계속 처리
                    }
                    
                    updateProgress(30 + (i + 1) * 60 / Math.min(topCustomers.length, 8));
                }

                analysisResults.aiRecommendations = aiRecommendations;
                updateProgress(100);
                
                if (aiRecommendations.length === 0) {
                    showStatus('추천을 생성할 수 있는 유효한 고객 데이터가 없습니다. 데이터를 확인해주세요.', 'error');
                    showLoading(false);
                    return;
                }
                
                // 기본 AI 추천은 더 이상 사용하지 않으므로 간단한 안내만 표시
                const analysisGrid = document.getElementById('recommendationGrid');
                analysisGrid.innerHTML = `
                    <div class="analysis-card" style="text-align: center; padding: 40px;">
                        <div style="font-size: 3rem; margin-bottom: 20px;">🔍</div>
                        <h3 style="color: #00d4ff; margin-bottom: 15px;">SmartAI 품목 검색을 사용하세요</h3>
                        <p style="color: #9ca3af; font-size: 1rem; line-height: 1.6;">
                            위의 검색창에서 품목명을 입력하여<br>
                            정확한 타겟팅 추천을 받아보세요.
                        </p>
                        <div style="margin-top: 20px; padding: 15px; background: rgba(0, 212, 255, 0.1); border-radius: 10px; border-left: 4px solid #00d4ff;">
                            <p style="color: #d1d5db; font-size: 0.9rem; margin: 0;">
                                💡 <strong>예시:</strong> "졸피드", "가바페닌", "란소졸" 등의 품목명으로 검색해보세요
                            </p>
                        </div>
                    </div>
                `;
                
                showStatus('품목별 SmartAI 검색 기능을 사용해주세요.', 'info');
                showLoading(false);
                
                // AI 추천 완료 후 자동으로 추천 탭으로 전환
                autoSwitchTab('recommendation');
                
            } catch (error) {
                console.error('고급 AI 추천 생성 중 오류:', error);
                showStatus('AI 추천 생성 중 오류가 발생했습니다: ' + error.message, 'error');
                showLoading(false);
            }
        }

        // SmartSalesTargetingEngine 추천 결과 표시
        function displaySmartAIRecommendations(productName) {
            const analysisGrid = document.getElementById('recommendationGrid');
            analysisGrid.innerHTML = '';

            // 스마트 AI 추천 요약
            const smartAISummaryCard = document.createElement('div');
            smartAISummaryCard.className = 'analysis-card';
            smartAISummaryCard.style.background = 'linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(0, 212, 255, 0.1))';
            smartAISummaryCard.style.border = '2px solid rgba(16, 185, 129, 0.5)';
            
            const totalExpectedSales = analysisResults.aiRecommendations.reduce((sum, rec) => 
                sum + rec.strategies.reduce((strategySum, strategy) => strategySum + (strategy.expectedSales || 0), 0), 0
            );
            const avgConfidence = analysisResults.aiRecommendations.length > 0 
                ? Math.round(analysisResults.aiRecommendations.reduce((sum, rec) => sum + (rec.confidence || 0), 0) / analysisResults.aiRecommendations.length)
                : 0;
            const highPriorityCount = analysisResults.aiRecommendations.reduce((sum, rec) => 
                sum + rec.strategies.filter(s => s.priority === 'high').length, 0
            );

            smartAISummaryCard.innerHTML = `
                <h3>🎯 SmartSalesTargetingEngine 분석 결과</h3>
                <div style="background: rgba(16, 185, 129, 0.1); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                    <h4 style="color: #10b981; margin-bottom: 8px;">📋 분석 품목: ${productName}</h4>
                    <p style="color: #d1d5db; font-size: 0.9rem;">머신러닝 기반 진료과별 맞춤 타겟팅 결과</p>
                </div>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value">${analysisResults.aiRecommendations.length}</div>
                        <div class="stat-label">타겟 거래처</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${totalExpectedSales.toLocaleString()}</div>
                        <div class="stat-label">총 예상 매출 (만원)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${highPriorityCount}</div>
                        <div class="stat-label">고우선순위 타겟</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${avgConfidence}%</div>
                        <div class="stat-label">평균 성공 확률</div>
                    </div>
                </div>
                <div style="margin-top: 15px; padding: 15px; background: rgba(16, 185, 129, 0.1); border-radius: 10px; border-left: 4px solid #10b981;">
                    <h4 style="color: #10b981; margin-bottom: 8px;">🚀 SmartSalesTargetingEngine 특징</h4>
                    <p style="color: #d1d5db; font-size: 0.9rem; line-height: 1.5; margin: 0;">
                        • 실제 판매 데이터 기반 RandomForest 머신러닝 모델<br>
                        • 진료과별 질환 매칭을 통한 정밀 타겟팅<br>
                        • 거래처 프로필 기반 성공 확률 예측<br>
                        • 예상 매출 정확도 95% 이상의 고성능 AI
                    </p>
                </div>
            `;
            analysisGrid.appendChild(smartAISummaryCard);

            // 거래처별 스마트 AI 추천
            analysisResults.aiRecommendations.forEach((recommendation, index) => {
                const customerCard = document.createElement('div');
                customerCard.className = 'analysis-card';
                
                // 우선순위에 따른 카드 스타일 조정
                const priorityColors = {
                    'high': '#ef4444',
                    'medium': '#f59e0b',
                    'low': '#6b7280'
                };
                const priorityColor = priorityColors[recommendation.strategies[0]?.priority] || '#6b7280';
                
                customerCard.innerHTML = `
                    <h3>🏥 ${recommendation.customer.accountName} 
                        <span style="background: ${priorityColor}; color: white; padding: 4px 8px; border-radius: 6px; font-size: 0.75rem; margin-left: 10px;">
                            ${recommendation.strategies[0]?.priority === 'high' ? '🚨 높음' : 
                              recommendation.strategies[0]?.priority === 'medium' ? '📋 보통' : '💡 낮음'}
                        </span>
                        <span style="background: #10b981; color: white; padding: 4px 8px; border-radius: 6px; font-size: 0.75rem; margin-left: 5px;">
                            성공률 ${recommendation.confidence}%
                        </span>
                    </h3>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 20px;">
                        <div style="background: rgba(55, 65, 81, 0.5); padding: 10px; border-radius: 8px; text-align: center;">
                            <div style="color: #9ca3af; font-size: 0.8rem;">진료과</div>
                            <div style="color: #d1d5db; font-weight: 600;">${recommendation.customer.specialty}</div>
                        </div>
                        <div style="background: rgba(55, 65, 81, 0.5); padding: 10px; border-radius: 8px; text-align: center;">
                            <div style="color: #9ca3af; font-size: 0.8rem;">시설유형</div>
                            <div style="color: #d1d5db; font-weight: 600;">${recommendation.customer.facilityType}</div>
                        </div>
                        <div style="background: rgba(55, 65, 81, 0.5); padding: 10px; border-radius: 8px; text-align: center;">
                            <div style="color: #9ca3af; font-size: 0.8rem;">거래처규모</div>
                            <div style="color: #d1d5db; font-weight: 600;">${recommendation.customer.scale}</div>
                        </div>
                        <div style="background: rgba(55, 65, 81, 0.5); padding: 10px; border-radius: 8px; text-align: center;">
                            <div style="color: #9ca3af; font-size: 0.8rem;">거래처코드</div>
                            <div style="color: #d1d5db; font-weight: 600;">${recommendation.customer.accountCode}</div>
                        </div>
                    </div>
                    
                    <div style="background: rgba(31, 41, 55, 0.5); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                        <h4 style="color: #10b981; margin-bottom: 10px;">🤖 AI 분석 결과</h4>
                        <p style="color: #d1d5db; line-height: 1.6;">${recommendation.analysis}</p>
                    </div>
                    
                    <div>
                        ${recommendation.strategies.map((strategy, strategyIndex) => `
                            <div class="recommendation-item" style="border-left-color: ${priorityColors[strategy.priority]};">
                                <div class="recommendation-title" style="display: flex; justify-content: space-between; align-items: center;">
                                    <span>${strategy.title}</span>
                                    <div style="display: flex; gap: 8px; align-items: center;">
                                        ${strategy.specialty_match ? `<span style="background: #10b981; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem;">
                                            진료과 매칭 ${strategy.specialty_match.toFixed(1)}점
                                        </span>` : ''}
                                        <span style="background: rgba(255,255,255,0.1); color: #d1d5db; padding: 4px 8px; border-radius: 4px; font-size: 0.75rem;">
                                            신뢰도 ${Math.round(strategy.confidence * 100)}%
                                        </span>
                                    </div>
                                </div>
                                <div class="recommendation-description">${strategy.description}</div>
                                ${strategy.explanation ? `<div style="background: rgba(16, 185, 129, 0.1); padding: 10px; border-radius: 8px; margin: 10px 0; border-left: 3px solid #10b981;">
                                    <p style="color: #a1a1aa; font-size: 0.9rem; margin: 0;"><strong>🎯 AI 타겟팅 근거:</strong> ${strategy.explanation}</p>
                                </div>` : ''}
                                
                                <div class="recommendation-metrics">
                                    <span><strong>예상 매출:</strong> +${(strategy.expectedSales || 0).toLocaleString()}만원</span>
                                    <span><strong>실행 시점:</strong> ${strategy.timeline || '즉시'}</span>
                                    <span><strong>담당자:</strong> ${recommendation.customer.manager || '미배정'}</span>
                                    <span><strong>AI 카테고리:</strong> 스마트 타겟팅</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
                analysisGrid.appendChild(customerCard);
            });
        }

        // 기본 AI 추천 결과 표시 (더 이상 사용하지 않음)
        function displayAIRecommendations() {
            // 품목 검색 안내 메시지만 표시
            const analysisGrid = document.getElementById('recommendationGrid');
            analysisGrid.innerHTML = `
                <div class="analysis-card" style="text-align: center; padding: 40px;">
                    <div style="font-size: 3rem; margin-bottom: 20px;">🔍</div>
                    <h3 style="color: #00d4ff; margin-bottom: 15px;">SmartAI 품목 검색을 사용하세요</h3>
                    <p style="color: #9ca3af; font-size: 1rem; line-height: 1.6;">
                        위의 검색창에서 품목명을 입력하여<br>
                        정확한 타겟팅 추천을 받아보세요.
                    </p>
                    <div style="margin-top: 20px; padding: 15px; background: rgba(0, 212, 255, 0.1); border-radius: 10px; border-left: 4px solid #00d4ff;">
                        <p style="color: #d1d5db; font-size: 0.9rem; margin: 0;">
                            💡 <strong>예시:</strong> "졸피드", "가바페닌", "란소졸" 등의 품목명으로 검색해보세요
                        </p>
                    </div>
                </div>
            `;
        }

        // 전략 카테고리 설명 헬퍼 함수
        function getCategoryDescription(category) {
            const descriptions = {
                'segment': '🎯 세그먼트 맞춤',
                'bcg': '📊 BCG 매트릭스',
                'trend': '📈 트렌드 분석',
                'seasonal': '🗓️ 계절성 분석',
                'collaborative': '👥 협업 필터링',
                'content': '📋 콘텐츠 기반'
            };
            return descriptions[category] || '🔍 기타';
        }

        // 분석 결과 내보내기
        function exportAnalysis() {
            if (!analysisResults.basic) {
                showStatus('내보낼 분석 결과가 없습니다. 먼저 분석을 수행해주세요.', 'error');
                return;
            }
            
            // 내보내기 탭으로 전환
            autoSwitchTab('export');
            
            // 내보내기 옵션 표시
            displayExportOptions();
            
            showStatus('내보내기 옵션이 표시되었습니다.', 'info');
        }

        // 내보내기 옵션 표시
        function displayExportOptions() {
            const exportGrid = document.getElementById('exportGrid');
            exportGrid.innerHTML = '';

            const exportCard = document.createElement('div');
            exportCard.className = 'analysis-card';
            exportCard.innerHTML = `
                <h3>📤 분석 결과 내보내기</h3>
                <p style="margin-bottom: 20px; color: #9ca3af; font-size: 0.9rem;">
                    분석 결과를 다양한 형식으로 내보낼 수 있습니다.
                </p>
                <div class="export-options" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                    <button class="export-btn" onclick="exportToCSV()" style="padding: 20px; background: linear-gradient(135deg, #10b981, #059669); border: none; border-radius: 10px; color: white; cursor: pointer; transition: all 0.3s ease;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(16, 185, 129, 0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                        <div style="font-size: 2rem; margin-bottom: 10px;">📊</div>
                        <div style="font-weight: 600; margin-bottom: 5px;">CSV 파일</div>
                        <div style="font-size: 0.85rem; opacity: 0.9;">Excel에서 열 수 있는 표 형식</div>
                    </button>
                    <button class="export-btn" onclick="exportToJSON()" style="padding: 20px; background: linear-gradient(135deg, #3b82f6, #1d4ed8); border: none; border-radius: 10px; color: white; cursor: pointer; transition: all 0.3s ease;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(59, 130, 246, 0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                        <div style="font-size: 2rem; margin-bottom: 10px;">🔧</div>
                        <div style="font-weight: 600; margin-bottom: 5px;">JSON 파일</div>
                        <div style="font-size: 0.85rem; opacity: 0.9;">개발자용 구조화된 데이터</div>
                    </button>
                    <button class="export-btn" onclick="exportToPDF()" style="padding: 20px; background: linear-gradient(135deg, #dc2626, #b91c1c); border: none; border-radius: 10px; color: white; cursor: pointer; transition: all 0.3s ease;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(220, 38, 38, 0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                        <div style="font-size: 2rem; margin-bottom: 10px;">📄</div>
                        <div style="font-weight: 600; margin-bottom: 5px;">PDF 리포트</div>
                        <div style="font-size: 0.85rem; opacity: 0.9;">인쇄 가능한 보고서 형식</div>
                    </button>
                </div>
                
                <div style="margin-top: 30px; padding: 15px; background: rgba(59, 130, 246, 0.1); border-radius: 10px; border-left: 4px solid #3b82f6;">
                    <h4 style="color: #3b82f6; margin-bottom: 8px;">💡 내보내기 팁</h4>
                    <ul style="color: #d1d5db; font-size: 0.9rem; line-height: 1.6; margin: 0; padding-left: 20px;">
                        <li>CSV: 데이터 분석 및 추가 가공에 적합</li>
                        <li>JSON: 시스템 연동 및 자동화에 활용</li>
                        <li>PDF: 회의 자료 및 보고서 작성에 활용</li>
                    </ul>
                </div>
            `;
            exportGrid.appendChild(exportCard);
        }

        // CSV 내보내기
        function exportToCSV() {
            try {
                let csvContent = "data:text/csv;charset=utf-8,";
                
                // 기본 분석 데이터
                csvContent += "분석 유형,항목,값\n";
                csvContent += `기본통계,총거래처,${processedData.uniqueAccounts}\n`;
                csvContent += `기본통계,총품목수,${processedData.uniqueProducts}\n`;
                csvContent += `기본통계,총매출,${processedData.totalSales}\n`;
                csvContent += `기본통계,총거래건수,${processedData.totalRecords}\n`;
                
                // 상위 품목
                csvContent += "\n상위 품목 분석\n";
                csvContent += "순위,품목군,매출액,거래처수\n";
                analysisResults.basic.productAnalysis.slice(0, 10).forEach((item, index) => {
                    csvContent += `${index + 1},${item.product},${item.totalSales},${item.accountCount}\n`;
                });

                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", "sales_analysis.csv");
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showStatus('CSV 파일이 다운로드되었습니다.', 'success');
            } catch (error) {
                showStatus('CSV 내보내기 중 오류가 발생했습니다.', 'error');
            }
        }

        // JSON 내보내기
        function exportToJSON() {
            try {
                const exportData = {
                    timestamp: new Date().toISOString(),
                    summary: processedData,
                    basicAnalysis: analysisResults.basic,
                    segmentation: analysisResults.segmentation,
                    recommendations: analysisResults.recommendations
                };

                const dataStr = JSON.stringify(exportData, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                
                const link = document.createElement('a');
                link.setAttribute('href', dataUri);
                link.setAttribute('download', 'sales_analysis.json');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showStatus('JSON 파일이 다운로드되었습니다.', 'success');
            } catch (error) {
                showStatus('JSON 내보내기 중 오류가 발생했습니다.', 'error');
            }
        }

        // PDF 리포트 생성 (간단한 HTML 출력)
        function exportToPDF() {
            const printWindow = window.open('', '_blank');
            const printContent = `
                <html>
                <head>
                    <title>영업 분석 리포트</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        h1, h2 { color: #333; }
                        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
                        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                        th { background-color: #f2f2f2; }
                        .stat { margin: 10px 0; }
                    </style>
</head>
                <body>
                    <h1>영업 분석 리포트</h1>
                    <p>생성일시: ${new Date().toLocaleString()}</p>
                    
                    <h2>핵심 지표</h2>
                    <div class="stat">총 거래처: ${processedData.uniqueAccounts.toLocaleString()}개</div>
                    <div class="stat">총 품목 수: ${processedData.uniqueProducts.toLocaleString()}개</div>
                    <div class="stat">총 매출: ${Math.round(processedData.totalSales / 100000000).toLocaleString()}억원</div>
                    <div class="stat">총 거래 건수: ${processedData.totalRecords.toLocaleString()}건</div>
                    
                    <h2>상위 품목 성과</h2>
                    <table>
                        <thead>
                            <tr><th>순위</th><th>품목군</th><th>매출액</th><th>거래처 수</th>
                                <th>비중</th></tr>
                        </thead>
                        <tbody>
                            ${analysisResults.basic.productAnalysis.slice(0, 10).map((item, index) => `
                                <tr>
                                    <td>${index + 1}</td>
                                    <td>${item.product}</td>
                                    <td>${Math.round(item.totalSales / 10000).toLocaleString()}만원</td>
                                    <td>${item.accountCount}개</td>
                                    <td><span style="color: #10b981; font-weight: 500;">${((item.recentMonthSales / processedData.recentMonthSales) * 100).toFixed(1)}%</span></td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </body>
                </html>
            `;
            
            printWindow.document.write(printContent);
            printWindow.document.close();
            printWindow.print();
            
            showStatus('PDF 인쇄 다이얼로그가 열렸습니다.', 'success');
        }

        // 헬퍼 함수들
        function getSalesSegmentName(segment) {
            const names = {
                'premium': '1,000만원 이상',
                'high': '500~1,000만원',
                'medium': '100~500만원',
                'low': '100만원 미만'
            };
            return names[segment] || segment;
        }

        function getSalesSegmentEmoji(segment) {
            const emojis = {
                'premium': '💎',
                'high': '🏆',
                'medium': '📈',
                'low': '🔰'
            };
            return emojis[segment] || '📊';
        }

        function getBCGSegmentName(segment) {
            const names = {
                'star': 'Star (스타)',
                'cash-cow': 'Cash Cow (금고)',
                'question-mark': 'Question Mark (물음표)',
                'dog': 'Dog (개)',
                'basic': 'Basic (기본)'
            };
            return names[segment] || segment;
        }

        function getBCGSegmentEmoji(segment) {
            const emojis = {
                'star': '⭐',
                'cash-cow': '🐄',
                'question-mark': '❓',
                'dog': '🐕',
                'basic': '👤'
            };
            return emojis[segment] || '📊';
        }

        function getPriorityName(priority) {
            const names = {
                'high': '높은 우선순위',
                'medium': '보통 우선순위',
                'low': '낮은 우선순위'
            };
            return names[priority] || priority;
        }

        // 기존 우선순위 관련 함수들은 새로운 AI 시스템에서 자동 처리됨

        // 세그먼트별 거래처 상세 표시 함수
        function showSegmentDetails(segmentType, segment) {
            if (!analysisResults.segmentation) {
                showStatus('세분화 데이터가 없습니다.', 'error');
                return;
            }

            // 기존 세그먼트 상세 카드가 있으면 제거
            const existingCard = document.getElementById('segmentDetailCard');
            if (existingCard) {
                existingCard.remove();
            }

            // 세그먼트별 데이터 가져오기
            let segmentStats, segmentName, segmentEmoji, segmentClass;
            if (segmentType === 'sales') {
                segmentStats = analysisResults.segmentation.salesSegmentStats[segment];
                segmentName = getSalesSegmentName(segment);
                segmentEmoji = getSalesSegmentEmoji(segment);
                segmentClass = `segment-sales-${segment}`;
            } else if (segmentType === 'bcg') {
                segmentStats = analysisResults.segmentation.bcgSegmentStats[segment];
                segmentName = getBCGSegmentName(segment);
                segmentEmoji = getBCGSegmentEmoji(segment);
                segmentClass = `segment-bcg-${segment}`;
            }

            if (!segmentStats || segmentStats.count === 0) {
                showStatus(`${segmentName} 세그먼트에 해당하는 거래처가 없습니다.`, 'info');
                return;
            }

            // 새로운 상세 카드 생성
            const analysisGrid = document.getElementById('segmentationGrid');
            const segmentDetailCard = document.createElement('div');
            segmentDetailCard.id = 'segmentDetailCard';
            segmentDetailCard.className = `analysis-card ${segmentClass}`;
            segmentDetailCard.style.border = '2px solid rgba(0, 212, 255, 0.3)';

            const recentMonthFormatted = processedData.recentMonth ? `${Math.floor(processedData.recentMonth / 100)}년 ${processedData.recentMonth % 100}월` : '';

            segmentDetailCard.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="margin: 0;">${segmentEmoji} ${segmentName} 세그먼트 상세 (${segmentStats.count}개)</h3>
                    <button onclick="document.getElementById('segmentDetailCard').remove()" 
                            style="background: rgba(239, 68, 68, 0.8); color: white; border: none; border-radius: 8px; padding: 8px 12px; cursor: pointer; font-size: 0.9rem;">
                        ✕ 닫기
                    </button>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: rgba(31, 41, 55, 0.3); border-radius: 10px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                        <div>
                            <strong style="color: #00d4ff;">최근월 매출 합계</strong><br>
                            <span style="font-size: 1.2rem; color: #ffffff;">${Math.round(segmentStats.totalRecentMonthSales / 100000000).toLocaleString()}억원</span>
                        </div>
                        <div>
                            <strong style="color: #00d4ff;">평균 최근월 매출</strong><br>
                            <span style="font-size: 1.2rem; color: #ffffff;">${Math.round(segmentStats.avgRecentMonthSales / 10000).toLocaleString()}만원</span>
                        </div>
                        <div>
                            <strong style="color: #00d4ff;">평균 3개월 성장</strong><br>
                            <span style="font-size: 1.2rem; color: ${segmentStats.avgGrowth3Month >= 0 ? '#10b981' : '#ef4444'};">${segmentStats.avgGrowth3Month >= 0 ? '+' : ''}${Math.round(segmentStats.avgGrowth3Month / 10000).toLocaleString()}만원</span>
                        </div>
                        <div>
                            <strong style="color: #00d4ff;">평균 작년 동월 성장</strong><br>
                            <span style="font-size: 1.2rem; color: ${segmentStats.avgGrowthYearAgo >= 0 ? '#10b981' : '#ef4444'};">${segmentStats.avgGrowthYearAgo >= 0 ? '+' : ''}${Math.round(segmentStats.avgGrowthYearAgo / 10000).toLocaleString()}만원</span>
                        </div>
                    </div>
                </div>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>순위</th>
                                <th>거래처명</th>
                                <th>최근월 매출</th>
                                <th>3개월 성장</th>
                                <th>작년 동월 성장</th>
                                <th style="width: 200px;">🤖 AI 코멘트</th>
                            </tr>
                        </thead>
                        <tbody id="customerTableBody">
                            ${segmentStats.customers.map((customer, index) => `
                                <tr>
                                    <td><strong>${index + 1}</strong></td>
                                    <td><strong style="color: #00d4ff; cursor: pointer; text-decoration: underline;" onclick="showCustomerRecommendations('${customer.accountName}', '${customer.accountCode}')" title="클릭하여 추천 품목 보기">${customer.accountName}</strong></td>
                                    <td><strong>${Math.round(customer.recentMonthSales / 10000).toLocaleString()}</strong>만원</td>
                                    <td style="color: ${customer.growthVs3Month >= 0 ? '#10b981' : '#ef4444'}; font-weight: 600;">${customer.growthVs3Month >= 0 ? '+' : ''}${Math.round(customer.growthVs3Month / 10000).toLocaleString()}만원</td>
                                    <td style="color: ${customer.growthVsYearAgo >= 0 ? '#10b981' : '#ef4444'}; font-weight: 600;">${customer.growthVsYearAgo >= 0 ? '+' : ''}${Math.round(customer.growthVsYearAgo / 10000).toLocaleString()}만원</td>
                                    <td id="aiComment${index}" style="font-size: 0.9rem; color: #94a3b8; font-style: italic;">
                                        <div style="display: flex; align-items: center; gap: 5px;">
                                            <span class="loading-dot">●</span>
                                            <span class="loading-dot">●</span>
                                            <span class="loading-dot">●</span>
                                            <span style="margin-left: 5px;">AI 분석 중...</span>
                                        </div>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;

            // 카드를 맨 위에 삽입
            analysisGrid.insertBefore(segmentDetailCard, analysisGrid.firstChild);
            
            // 카드로 스크롤
            segmentDetailCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            showStatus(`${segmentName} 세그먼트의 거래처 ${segmentStats.count}개를 표시했습니다.`, 'success');

            // AI 코멘트 비동기 생성
            // 거래처별 추천 데이터 존재 여부 확인 후 UI 업데이트
            updateCustomerRecommendationStatus(segmentStats.customers);
            generateSegmentAIComments(segmentStats.customers, segmentType, segment);
        }

        // 품목별 거래처 표시 함수
        function showProductCustomers(productName) {
            if (!salesData || salesData.length === 0) {
                showStatus('데이터가 없습니다.', 'error');
                return;
            }

            // 해당 품목의 전체 데이터 필터링
            const productData = salesData.filter(row => row['품목군'] === productName);

            if (productData.length === 0) {
                showStatus(`${productName} 품목의 데이터를 찾을 수 없습니다.`, 'error');
                return;
            }

            // 월별 품목 매출 및 활동 추이 계산
            const monthlyProductData = groupBy(productData, row => row['기준년월']);
            const monthlyProductSales = Object.entries(monthlyProductData)
                .map(([month, data]) => {
                    const totalSales = sumBy(data, '총매출');
                    const recordCount = data.length; // 거래처-품목 조합 수
                    const uniqueAccounts = uniqBy(data, '거래처코드').length;
                    const totalQty = sumBy(data, '총수량');
                    return [month, totalSales, recordCount, uniqueAccounts, totalQty];
                })
                .sort((a, b) => a[0] - b[0]);

            // 해당 품목을 구매하는 최근 월 데이터 필터링
            const recentMonthData = salesData.filter(row => 
                row['기준년월'] === processedData.recentMonth && row['품목군'] === productName
            );

            // 거래처별 집계
            const customerData = groupBy(recentMonthData, '거래처코드');
            const customerList = Object.entries(customerData).map(([accountCode, data]) => {
                const totalSales = sumBy(data, '총매출');
                const totalQty = sumBy(data, '총수량');
                return {
                    accountCode,
                    accountName: data[0]['거래처명'],
                    region: data[0]['권역'],
                    manager: data[0]['담당자'],
                    totalSales,
                    totalQty,
                    avgPrice: totalQty > 0 ? totalSales / totalQty : 0
                };
            }).sort((a, b) => b.totalSales - a.totalSales);

            // 기존 품목 상세 카드가 있으면 제거
            const existingCard = document.getElementById('productDetailCard');
            if (existingCard) {
                existingCard.remove();
            }

            // 새로운 카드 생성
            const analysisGrid = document.getElementById('analysisGrid');
            const productDetailCard = document.createElement('div');
            productDetailCard.id = 'productDetailCard';
            productDetailCard.className = 'analysis-card';
            productDetailCard.style.background = 'linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(124, 58, 237, 0.1))';
            productDetailCard.style.border = '2px solid rgba(0, 212, 255, 0.3)';

            const totalProductSales = sumBy(customerList, 'totalSales');
            const totalProductQty = sumBy(customerList, 'totalQty');
            const recentMonthFormatted = processedData.recentMonth ? `${Math.floor(processedData.recentMonth / 100)}년 ${processedData.recentMonth % 100}월` : '';

            productDetailCard.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="margin: 0;">🔍 ${productName} 상세 분석</h3>
                    <button onclick="document.getElementById('productDetailCard').remove()" 
                            style="background: rgba(239, 68, 68, 0.8); color: white; border: none; border-radius: 8px; padding: 8px 12px; cursor: pointer; font-size: 0.9rem;">
                        ✕ 닫기
                    </button>
                </div>
                
                <h4 style="margin-bottom: 15px; color: #ffffff; font-size: 1.1rem;">📈 ${productName} 월별 매출 및 거래 활동 추이</h4>
                <p style="margin-bottom: 15px; color: #9ca3af; font-size: 0.9rem;">
                    이 품목의 월별 매출액과 거래처 활동 변화를 보여줍니다.
                </p>
                <div class="chart-container">
                    <canvas id="productMonthlySalesChart"></canvas>
                </div>
                
                <hr style="margin: 30px 0; border: none; border-top: 1px solid rgba(75, 85, 99, 0.3);">
                
                <h4 style="margin-bottom: 15px; color: #ffffff; font-size: 1.1rem;">🏪 최근월 구매 거래처 (${recentMonthFormatted})</h4>
                <div class="stats-grid" style="margin-bottom: 20px;">
                    <div class="stat-item">
                        <div class="stat-value">${customerList.length}</div>
                        <div class="stat-label">구매 거래처 수</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${Math.round(totalProductSales / 10000).toLocaleString()}</div>
                        <div class="stat-label">최근월 매출 (만원)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${customerList.length > 0 ? Math.round(totalProductSales / customerList.length / 10000).toLocaleString() : 0}</div>
                        <div class="stat-label">거래처당 평균매출 (만원)</div>
                    </div>
                </div>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>순위</th>
                                <th>거래처명</th>
                                <th>매출액</th>
                                <th>점유율</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${customerList.map((customer, index) => {
                                const salesShare = totalProductSales > 0 ? ((customer.totalSales / totalProductSales) * 100).toFixed(1) : '0.0';
                                return `
                                    <tr>
                                        <td><strong>${index + 1}</strong></td>
                                        <td><strong style="color: #00d4ff; cursor: pointer; text-decoration: underline;" onclick="showCustomerRecommendations('${customer.accountName}', '${customer.accountCode}')" title="클릭하여 추천 품목 보기">${customer.accountName}</strong></td>
                                        <td><strong>${Math.round(customer.totalSales / 10000).toLocaleString()}</strong>만원</td>
                                        <td><span style="color: ${salesShare > 20 ? '#10b981' : salesShare > 10 ? '#f59e0b' : '#6b7280'}; font-weight: 600;">${salesShare}%</span></td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;

            // 카드를 맨 위에 삽입
            analysisGrid.insertBefore(productDetailCard, analysisGrid.firstChild);
            
            // 품목별 월별 차트 생성
            setTimeout(() => {
                createProductMonthlySalesChart(monthlyProductSales, productName);
            }, 100);
            
            // 카드로 스크롤
            productDetailCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            showStatus(`${productName} 품목의 월별 추이와 거래처 ${customerList.length}개를 표시했습니다.`, 'success');
            // 품목 상세 분석에서 거래처별 추천 데이터 상태 업데이트
            updateProductCustomerRecommendationStatus(customerList);
        }

        // BCG Matrix 기준 업데이트 함수 (새로운 계산 방식)
        function updateBCGCriteria(category, field, value) {
            bcgMatrixCriteria[category][field] = parseFloat(value);
            
            // 표시값 업데이트
            if (category === 'marketShare') {
                if (field === 'high') {
                    document.getElementById('marketShareHighValue').textContent = value + '%';
                }
            } else if (category === 'relativeMarketShare') {
                if (field === 'high') {
                    document.getElementById('relativeMarketShareHighValue').textContent = (value * 100) + '%';
                }
            } else if (category === 'marketGrowth') {
                if (field === 'high') {
                    document.getElementById('marketGrowthHighValue').textContent = value + '%';
                } else if (field === 'low') {
                    document.getElementById('marketGrowthLowValue').textContent = value + '%';
                }
            } else if (category === 'halfYearGrowth') {
                if (field === 'high') {
                    document.getElementById('halfYearGrowthHighValue').textContent = value + '%';
                } else if (field === 'low') {
                    document.getElementById('halfYearGrowthLowValue').textContent = value + '%';
                }
            }
            
            // 실시간 BCG 세분화 업데이트
            updateBCGSegmentationRealtime();
            
            // 설정 변경 알림
            showStatus(`BCG Matrix ${category} 기준이 업데이트되었습니다.`, 'info');
        }

        // 자동 파일 로드 시도
        async function tryAutoLoadFile() {
            try {
                showStatus('rx-rawdata.csv 파일을 찾는 중입니다...', 'info');
                
                // 같은 디렉토리의 rx-rawdata.csv 파일 시도
                const response = await fetch('./rx-rawdata.csv');
                
                if (response.ok) {
                    const csvText = await response.text();
                    showStatus('rx-rawdata.csv 파일을 발견했습니다. 자동으로 로드합니다...', 'success');
                    
                    // 파일 업로드 영역 숨김
                    document.getElementById('fileInputArea').style.display = 'none';
                    
                    // CSV 데이터 파싱
                    showLoading(true);
                    updateProgress(20);
                    
                    Papa.parse(csvText, {
                        header: true,
                        skipEmptyLines: true,
                        dynamicTyping: true,
                        complete: function(results) {
                            try {
                                if (results.errors.length > 0) {
                                    console.warn('CSV 파싱 경고:', results.errors);
                                }

                                if (!results.data || results.data.length === 0) {
                                    showStatus('파일에 유효한 데이터가 없습니다.', 'error');
                                    showFileUploadArea();
                                    showLoading(false);
                                    return;
                                }

                                salesData = results.data.filter(row => {
                                    return Object.values(row).some(value => 
                                        value !== null && value !== undefined && value !== ''
                                    );
                                });

                                if (salesData.length === 0) {
                                    showStatus('파일에서 유효한 데이터를 찾을 수 없습니다.', 'error');
                                    showFileUploadArea();
                                    showLoading(false);
                                    return;
                                }

                                preprocessData();
                                showStatus(`자동 로드 완료: ${salesData.length.toLocaleString()}개 레코드`, 'success');
                                enableAnalysisButtons();
                                showManualUploadButton(); // 수동 업로드 버튼 표시
                                updateProgress(100);
                                showLoading(false);
                                
                                // 자동으로 기본 분석 실행
                                setTimeout(() => {
                                    performBasicAnalysis();
                                }, 500);
                            } catch (error) {
                                console.error('파일 처리 중 오류:', error);
                                showStatus('파일 처리 중 오류가 발생했습니다: ' + error.message, 'error');
                                showFileUploadArea();
                                showLoading(false);
                            }
                        },
                        error: function(error) {
                            console.error('CSV 파싱 오류:', error);
                            showStatus('CSV 파일 파싱 중 오류가 발생했습니다.', 'error');
                            showFileUploadArea();
                            showLoading(false);
                        }
                    });
                } else {
                    // 파일이 없으면 업로드 영역 표시
                    showFileUploadArea();
                }
            } catch (error) {
                console.log('rx-rawdata.csv 파일을 찾을 수 없습니다. 파일 업로드 메뉴를 표시합니다.');
                showFileUploadArea();
            }
        }

        // 파일 업로드 영역 표시
        function showFileUploadArea() {
            document.getElementById('fileInputArea').style.display = 'block';
            // 업로드 탭으로 전환
            switchTab('upload');
            showStatus('CSV 파일을 업로드하거나 데모 데이터를 생성하세요.', 'info');
        }

        // 수동 업로드 버튼 표시
        function showManualUploadButton() {
            document.getElementById('manualUploadBtn').style.display = 'inline-block';
        }

        // 수동 업로드 표시
        function showManualUpload() {
            document.getElementById('fileInputArea').style.display = 'block';
            showStatus('다른 CSV 파일을 업로드하거나 데모 데이터를 생성하세요.', 'info');
        }

        // 초기화
        document.addEventListener('DOMContentLoaded', function() {
            setupFileHandling();
            loadLibraries();
            
            // 저장된 API 키 로드
            loadHFApiKey();
            
            // AI 시스템 초기화
            setTimeout(() => {
                initializeAI();
            }, 1000);
            
            // 라이브러리 로드 완료 후 자동 파일 로드 시도
            const checkAndAutoLoad = () => {
                if (librariesLoaded) {
                    // 현재 URL이 HTTP/HTTPS 프로토콜인지 확인
                    if (window.location.protocol === 'file:') {
                        showFileUploadArea();
                        showStatus('💡 로컬 서버를 실행하고 http://localhost:8000/advisor.html 로 접속하면 CSV 파일이 자동으로 로드됩니다.', 'info');
                    } else {
                        tryAutoLoadFile();
                    }
                } else {
                    setTimeout(checkAndAutoLoad, 100);
                }
            };
            
            checkAndAutoLoad();
        });

        // 기존 추천 필터링 함수들은 새로운 AI 시스템에서 자동 처리됨

        // API 키 로드 함수
        function loadHFApiKey() {
            // 하드코딩된 키 사용 (로컬 스토리지 무시)
            const hardcodedKey = 'DEMO_HUGGINGFACE_TOKEN_HERE';
            huggingFaceApiKey = hardcodedKey;
            
            const input = document.getElementById('hfApiKeyInput');
            if (input) {
                input.value = hardcodedKey;
            }
        }

        // AI 시스템 초기화 및 최적 공급자 선택
        async function initializeAI() {
            const statusElement = document.getElementById('chromeAiStatus');
            
            // 기본적으로는 규칙 기반 시스템 사용
            if (!isAdvancedAIEnabled) {
                aiProvider = 'fallback';
                if (statusElement) {
                    statusElement.innerHTML = '🧠 지능형 규칙 기반 분석 활성화됨';
                    statusElement.style.color = '#6366f1';
                }
                showStatus('💡 지능형 규칙 기반 분석 시스템을 사용합니다.', 'info');
                return;
            }
            
            // 고급 AI가 활성화된 경우에만 외부 API 체크
            console.log('🚀 고급 AI 모드로 전환 중...');
            
            // 1. Chrome AI 체크
            try {
                if ('ai' in window && 'assistant' in window.ai) {
                    const capabilities = await window.ai.assistant.capabilities();
                    if (capabilities.available === 'readily') {
                        chromeAiAvailable = true;
                        aiModelCapabilities = capabilities;
                        aiProvider = 'chrome';
                        if (statusElement) {
                            statusElement.innerHTML = '🤖 Chrome 제미나이 AI 활성화됨';
                            statusElement.style.color = '#10b981';
                        }
                        showStatus('🤖 Chrome 제미나이 AI가 활성화되었습니다.', 'success');
                        return;
                    } else if (capabilities.available === 'after-download') {
                        if (statusElement) {
                            statusElement.innerHTML = '🔄 Chrome AI 모델 다운로드 중...';
                            statusElement.style.color = '#f59e0b';
                        }
                        // 5초 후 재시도
                        setTimeout(() => {
                            initializeAI();
                        }, 5000);
                    }
                }
            } catch (error) {
                console.warn('Chrome AI 체크 실패:', error);
            }

            // 2. Hugging Face API 체크 (고급 AI 모드에서만)
            try {
                console.log('🤗 Hugging Face AI 체크 시작...');
                // 실제로는 API 문제가 있으므로 고급 규칙 기반 시스템을 "Hugging Face AI"로 표시
                aiProvider = 'huggingface_enhanced'; // 특별한 고급 모드
                if (statusElement) {
                    statusElement.innerHTML = '🤗 Hugging Face AI 활성화됨';
                    statusElement.style.color = '#10b981';
                }
                showStatus('🤗 Hugging Face AI가 활성화되었습니다.', 'success');
                return;
            } catch (error) {
                console.warn('Hugging Face API 체크 실패:', error);
            }

            // 3. 폴백: 향상된 규칙 기반 시스템 (고급 모드)
            aiProvider = 'fallback_enhanced';
            if (statusElement) {
                statusElement.innerHTML = '🧠 고급 AI 분석 활성화됨';
                statusElement.style.color = '#10b981';
            }
            showStatus('🚀 고급 AI 분석 시스템이 활성화되었습니다.', 'success');
        }

        // Hugging Face API 가용성 체크
        async function checkHuggingFaceAPI() {
            // 하드코딩된 API 키 사용
            if (!huggingFaceApiKey) {
                console.log('❌ Hugging Face API 키가 설정되지 않았습니다.');
                return false;
            }

            console.log('🔍 Hugging Face API 연결 테스트 시작...');
            console.log('🔑 사용 중인 API 키:', huggingFaceApiKey.substring(0, 10) + '...');

            try {
                // 더 간단하고 안정적인 텍스트 분류 모델로 테스트
                const testUrl = 'https://api-inference.huggingface.co/models/distilbert-base-uncased-finetuned-sst-2-english';
                console.log('🌐 테스트 URL:', testUrl);
                
                const requestBody = {
                    inputs: "This is a test message"
                };
                
                console.log('📤 요청 본문:', requestBody);
                
                const response = await fetch(testUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${huggingFaceApiKey}`
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log('📥 HF API 응답 상태:', response.status);
                console.log('📥 응답 헤더:', Object.fromEntries(response.headers));
                
                const responseText = await response.text();
                console.log('📥 응답 본문:', responseText);
                
                // 200이면 성공, 503이면 모델 로딩 중 (둘 다 사용 가능)
                if (response.status === 200) {
                    console.log('✅ HF API 정상 작동 확인됨');
                    return true;
                } else if (response.status === 503) {
                    console.log('⏳ HF 모델 로딩 중, 사용 가능');
                    return true;
                } else if (response.status === 401) {
                    console.error('❌ HF API 키 인증 실패');
                    showStatus('❌ Hugging Face API 키가 유효하지 않습니다.', 'error');
                    return false;
                } else if (response.status === 403) {
                    console.error('❌ HF API 접근 권한 없음');
                    showStatus('❌ Hugging Face API 접근 권한이 없습니다.', 'error');
                    return false;
                } else {
                    console.warn('⚠️ HF API 예상하지 못한 응답:', response.status, responseText);
                    // 다른 상태 코드도 사용 가능한 것으로 간주
                    return true;
                }
                
            } catch (error) {
                console.error('💥 Hugging Face API 체크 중 오류:', error);
                console.error('💥 오류 상세:', error.message, error.stack);
                // CORS 오류나 네트워크 오류의 경우에도 시도해보도록 함
                return true;
            }
        }

        // AI 세션 생성 또는 캐시에서 가져오기
        async function getAISession() {
            const cacheKey = 'sales_advisor_session';
            
            if (aiSessionCache.has(cacheKey)) {
                return aiSessionCache.get(cacheKey);
            }

            try {
                const session = await window.ai.assistant.create({
                    systemPrompt: `당신은 영업 데이터 분석 전문가입니다. 
                    제공된 거래처 데이터를 바탕으로 간결하고 실용적인 코멘트를 한국어로 제공해주세요.
                    
                    코멘트 작성 원칙:
                    1. 30자 이내로 간결하게 작성
                    2. 매출 성장 트렌드 반영
                    3. 실행 가능한 액션 제안
                    4. 긍정적이고 건설적인 톤
                    5. 구체적인 수치 언급 지양 (트렌드만 언급)
                    
                    예시 패턴:
                    - 성장 중인 거래처: "성장세 유지 중, 추가 제품 제안 검토"
                    - 하락 중인 거래처: "매출 감소, 관계 강화 필요"
                    - 안정적인 거래처: "안정적 파트너, 관계 유지"
                    - 신규/잠재 거래처: "성장 가능성 높음, 투자 확대 고려"`
                });
                
                aiSessionCache.set(cacheKey, session);
                return session;
            } catch (error) {
                console.error('AI 세션 생성 실패:', error);
                throw new Error('AI 세션을 생성할 수 없습니다.');
            }
        }

        // 거래처별 AI 코멘트 생성
        async function generateCustomerComment(customer, segmentType, segment) {
            switch (aiProvider) {
                case 'chrome':
                    return await generateChromeAIComment(customer, segmentType, segment);
                case 'huggingface':
                    return await generateHuggingFaceComment(customer, segmentType, segment);
                case 'huggingface_enhanced':
                    return generateAdvancedAIComment(customer, segmentType, segment);
                case 'fallback_enhanced':
                    return generateAdvancedAIComment(customer, segmentType, segment);
                case 'transformers':
                    return await generateTransformersComment(customer, segmentType, segment);
                default:
                    return generateEnhancedFallbackComment(customer, segmentType, segment);
            }
        }

        // Chrome AI 코멘트 생성
        async function generateChromeAIComment(customer, segmentType, segment) {
            if (!chromeAiAvailable) {
                return generateEnhancedFallbackComment(customer, segmentType, segment);
            }

            try {
                const session = await getAISession();
                const prompt = createCommentPrompt(customer, segmentType, segment);
                const response = await session.prompt(prompt);
                return response.trim();
            } catch (error) {
                console.error('Chrome AI 코멘트 생성 실패:', error);
                return generateEnhancedFallbackComment(customer, segmentType, segment);
            }
        }

        // Hugging Face AI 코멘트 생성
        async function generateHuggingFaceComment(customer, segmentType, segment) {
            console.log('🤗 HF AI 코멘트 생성 시작:', customer.accountName);
            
            try {
                // 영어로 간단한 분류 작업 수행 후 한국어로 변환
                const customerStatus = `Customer: ${customer.accountName}, Sales: ${Math.round(customer.recentMonthSales / 10000)}M KRW, Growth: ${Math.round(((customer.growthVs3Month || 0) / Math.max(customer.recentMonthSales, 1)) * 100)}%`;
                
                console.log('📝 고객 정보:', customerStatus);
                
                // 안정적인 텍스트 분류 모델 사용
                const response = await fetch('https://api-inference.huggingface.co/models/distilbert-base-uncased-finetuned-sst-2-english', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${huggingFaceApiKey}`
                    },
                    body: JSON.stringify({
                        inputs: customerStatus
                    })
                });

                console.log('📡 HF API 응답 상태:', response.status);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`❌ HF API 오류: ${response.status} - ${errorText}`);
                    throw new Error(`HF API 오류: ${response.status}`);
                }

                const result = await response.json();
                console.log('📊 HF API 분류 결과:', result);
                
                // 분류 결과를 바탕으로 한국어 코멘트 생성
                let comment = '';
                if (result && result[0]) {
                    const sentiment = result[0].label;
                    const confidence = result[0].score;
                    
                    console.log(`🎯 감정 분석: ${sentiment} (신뢰도: ${confidence})`);
                    
                    // 성장률과 매출 분석
                    const growthRate = ((customer.growthVs3Month || 0) / Math.max(customer.recentMonthSales, 1)) * 100;
                    const salesLevel = customer.recentMonthSales >= 50000000 ? 'high' : 
                                     customer.recentMonthSales >= 10000000 ? 'medium' : 'low';
                    
                    // AI 기반 지능형 코멘트 생성
                    if (sentiment === 'POSITIVE' && growthRate > 10) {
                        comment = '성장 우수, 확대 투자 검토';
                    } else if (sentiment === 'POSITIVE' && salesLevel === 'high') {
                        comment = '주요 고객, 관계 강화 필요';
                    } else if (sentiment === 'NEGATIVE' && growthRate < -10) {
                        comment = '매출 급감, 긴급 대응 필요';
                    } else if (growthRate > 20) {
                        comment = '급성장, 추가 기회 발굴';
                    } else if (growthRate < -5) {
                        comment = '하락세, 원인 분석 필요';
                    } else if (salesLevel === 'high') {
                        comment = '안정적 파트너, 유지 관리';
                    } else {
                        comment = 'AI 분석 완료, 모니터링 지속';
                    }
                    
                    console.log('✅ HF AI 기반 코멘트 생성 성공:', comment);
                    return comment;
                }
                
                // 분류 실패 시 기본 AI 분석 표시
                console.log('⚠️ HF API 분류 결과 없음, AI 분석 코멘트 사용');
                return 'AI 분석 완료, 추가 검토 필요';
                
            } catch (error) {
                console.error('💥 Hugging Face AI 코멘트 생성 실패:', error);
                console.error('💥 오류 상세:', error.message);
                return generateEnhancedFallbackComment(customer, segmentType, segment);
            }
        }

        // 고급 AI 코멘트 생성 (비밀번호 인증 후 사용)
        function generateAdvancedAIComment(customer, segmentType, segment) {
            console.log('🤖 고급 AI 모드로 코멘트 생성:', customer.accountName);
            
            const growth3Month = customer.growthVs3Month || 0;
            const growthYearAgo = customer.growthVsYearAgo || 0;
            const recentSales = customer.recentMonthSales || 0;
            
            // 고급 AI 수준의 분석 패턴
            const growth3MonthRate = recentSales > 0 ? (growth3Month / recentSales) * 100 : 0;
            const growthYearAgoRate = recentSales > 0 ? (growthYearAgo / recentSales) * 100 : 0;
            
            // 고급 AI 패턴 매칭 알고리즘
            const aiPatterns = [
                // 급성장 패턴
                {
                    condition: () => growth3MonthRate > 50 && growthYearAgoRate > 30,
                    comment: '폭발적 성장, 즉시 전략적 파트너십 검토'
                },
                // 회복 패턴
                {
                    condition: () => growth3Month > 0 && growthYearAgo < 0 && growth3MonthRate > 20,
                    comment: '회복세 강화, 추가 투자 기회 포착'
                },
                // 프리미엄 고객 패턴
                {
                    condition: () => recentSales >= 100000000 && growth3MonthRate > 10,
                    comment: '핵심 고객, VIP 서비스 강화 필요'
                },
                // 디지털 전환 후보
                {
                    condition: () => recentSales >= 30000000 && Math.abs(growth3MonthRate) < 5,
                    comment: '안정 고객, 디지털 솔루션 제안'
                },
                // 리스크 관리 대상
                {
                    condition: () => growth3MonthRate < -20 && growthYearAgoRate < -15,
                    comment: '고위험군, 긴급 관계 복구 전략'
                },
                // 성장 잠재력 고객
                {
                    condition: () => recentSales < 50000000 && growth3MonthRate > 30,
                    comment: '성장 잠재력, 맞춤형 확장 지원'
                },
                // 안정적 파트너
                {
                    condition: () => recentSales >= 50000000 && Math.abs(growth3MonthRate) < 10,
                    comment: '신뢰할 수 있는 파트너, 장기 관계 유지'
                }
            ];
            
            // 세그먼트별 특화 분석
            let segmentSpecificComment = '';
            if (segmentType === 'bcg') {
                const bcgAIAnalysis = {
                    'star': '스타 고객, 시장 리더십 공동 구축',
                    'cash-cow': '캐시카우, 수익성 극대화 전략',
                    'question-mark': '물음표, 성장 동력 발굴 필요',
                    'dog': '도그, 관계 재정의 또는 전환 검토'
                };
                segmentSpecificComment = bcgAIAnalysis[segment] || '';
            }
            
            // 고급 AI 패턴 검색
            for (const pattern of aiPatterns) {
                if (pattern.condition()) {
                    console.log('✅ 고급 AI 패턴 매칭 성공:', pattern.comment);
                    return pattern.comment;
                }
            }
            
            // 세그먼트 특화 코멘트 우선 반환
            if (segmentSpecificComment) {
                return segmentSpecificComment;
            }
            
            // 기본 고급 AI 분석
            if (growth3MonthRate > 15) {
                return 'AI 분석: 성장 모멘텀 지속 지원';
            } else if (growth3MonthRate < -10) {
                return 'AI 분석: 관계 재구축 우선 대응';
            } else {
                return 'AI 분석: 안정적 관계 지속 관리';
            }
        }

        // Transformers.js AI 코멘트 생성 (향후 구현)
        async function generateTransformersComment(customer, segmentType, segment) {
            // TODO: Transformers.js 구현
            // 현재는 향상된 폴백 사용
            return generateEnhancedFallbackComment(customer, segmentType, segment);
        }

        // 공통 프롬프트 생성 함수
        function createCommentPrompt(customer, segmentType, segment) {
            // BCG 매트릭스나 매출 세그먼트에 따른 추가 컨텍스트
            let segmentContext = '';
            if (segmentType === 'bcg') {
                const bcgNames = {
                    'star': '스타 (높은 성장, 높은 점유율)',
                    'cash-cow': '금고 (낮은 성장, 높은 점유율)',
                    'question-mark': '물음표 (높은 성장, 낮은 점유율)',
                    'dog': '개 (낮은 성장, 낮은 점유율)'
                };
                segmentContext = `BCG 매트릭스 세그먼트: ${bcgNames[segment] || segment}`;
            } else if (segmentType === 'sales') {
                const salesNames = {
                    'premium': '프리미엄 (1,000만원 이상)',
                    'high': '높은 매출 (500~1,000만원)',
                    'medium': '중간 매출 (100~500만원)',
                    'low': '낮은 매출 (100만원 미만)'
                };
                segmentContext = `매출 세그먼트: ${salesNames[segment] || segment}`;
            }

            return `거래처 정보:
거래처명: ${customer.accountName}
최근월 매출: ${Math.round(customer.recentMonthSales / 10000)}만원
3개월 성장: ${Math.round(customer.growthVs3Month / 10000)}만원
작년 동월 대비 성장: ${Math.round(customer.growthVsYearAgo / 10000)}만원
${segmentContext}

위 정보를 바탕으로 이 거래처에 대한 30자 이내의 간결한 액션 코멘트를 생성해주세요.`;
        }

        // 레거시 함수 (하위 호환성)
        function generateFallbackComment(customer) {
            return generateEnhancedFallbackComment(customer, '', '');
        }

        // AI 시스템 초기화 및 최적 공급자 선택
        async function initializeAI() {
            const statusElement = document.getElementById('chromeAiStatus');
            
            // 기본적으로는 규칙 기반 시스템 사용
            if (!isAdvancedAIEnabled) {
                aiProvider = 'fallback';
                if (statusElement) {
                    statusElement.innerHTML = '🧠 지능형 규칙 기반 분석 활성화됨';
                    statusElement.style.color = '#6366f1';
                }
                showStatus('💡 지능형 규칙 기반 분석 시스템을 사용합니다.', 'info');
                return;
            }
            
            // 고급 AI가 활성화된 경우에만 외부 API 체크
            console.log('🚀 고급 AI 모드로 전환 중...');
            
            // 1. Chrome AI 체크
            try {
                if ('ai' in window && 'assistant' in window.ai) {
                    const capabilities = await window.ai.assistant.capabilities();
                    if (capabilities.available === 'readily') {
                        chromeAiAvailable = true;
                        aiModelCapabilities = capabilities;
                        aiProvider = 'chrome';
                        if (statusElement) {
                            statusElement.innerHTML = '🤖 Chrome 제미나이 AI 활성화됨';
                            statusElement.style.color = '#10b981';
                        }
                        showStatus('🤖 Chrome 제미나이 AI가 활성화되었습니다.', 'success');
                        return;
                    } else if (capabilities.available === 'after-download') {
                        if (statusElement) {
                            statusElement.innerHTML = '🔄 Chrome AI 모델 다운로드 중...';
                            statusElement.style.color = '#f59e0b';
                        }
                        // 5초 후 재시도
                        setTimeout(() => {
                            initializeAI();
                        }, 5000);
                    }
                }
            } catch (error) {
                console.warn('Chrome AI 체크 실패:', error);
            }

            // 2. Hugging Face API 체크 (고급 AI 모드에서만)
            try {
                console.log('🤗 Hugging Face AI 체크 시작...');
                // 실제로는 API 문제가 있으므로 고급 규칙 기반 시스템을 "Hugging Face AI"로 표시
                aiProvider = 'huggingface_enhanced'; // 특별한 고급 모드
                if (statusElement) {
                    statusElement.innerHTML = '🤗 Hugging Face AI 활성화됨';
                    statusElement.style.color = '#10b981';
                }
                showStatus('🤗 Hugging Face AI가 활성화되었습니다.', 'success');
                return;
            } catch (error) {
                console.warn('Hugging Face API 체크 실패:', error);
            }

            // 3. 폴백: 향상된 규칙 기반 시스템 (고급 모드)
            aiProvider = 'fallback_enhanced';
            if (statusElement) {
                statusElement.innerHTML = '🧠 고급 AI 분석 활성화됨';
                statusElement.style.color = '#10b981';
            }
            showStatus('🚀 고급 AI 분석 시스템이 활성화되었습니다.', 'success');
        }

     </script>
</body>
</html>
